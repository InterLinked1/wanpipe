Only in wanec/buffers: CVS
Only in wanec/buffers: DTMF_0_ulaw.pcm
Only in wanec/buffers: DTMF_1_ulaw.pcm
Only in wanec/buffers: DTMF_2_ulaw.pcm
Only in wanec/buffers: DTMF_3_ulaw.pcm
Only in wanec/buffers: DTMF_4_ulaw.pcm
Only in wanec/buffers: DTMF_5_ulaw.pcm
Only in wanec/buffers: DTMF_6_ulaw.pcm
Only in wanec/buffers: DTMF_7_ulaw.pcm
Only in wanec/buffers: DTMF_8_ulaw.pcm
Only in wanec/buffers: DTMF_9_ulaw.pcm
Only in wanec/buffers: DTMF_A_ulaw.pcm
Only in wanec/buffers: DTMF_B_ulaw.pcm
Only in wanec/buffers: DTMF_C_ulaw.pcm
Only in wanec/buffers: DTMF_D_ulaw.pcm
Only in wanec/buffers: DTMF_POUND_ulaw.pcm
Only in wanec/buffers: DTMF_STAR_ulaw.pcm
Only in wanec/buffers: female_voice1_a_law.pcm
Only in wanec/buffers: female_voice1_u_law.pcm
Only in wanec/buffers: male_voice1_a_law.pcm
Only in wanec/buffers: male_voice1_u_law.pcm
Only in wanec/buffers: male_voice2_a_law.pcm
Only in wanec/buffers: male_voice2_u_law.pcm
Only in wanec/buffers: oct_phone_number_a_law.pcm
Only in wanec/buffers: oct_phone_number_u_law.pcm
Only in wanec/buffers: Rin_a_law.pcm
Only in wanec/buffers: Rin_u_law.pcm
Only in wanec/buffers: Sin_a_law.pcm
Only in wanec/buffers: Sin_u_law.pcm
Only in wanec/buffers: voice_long_a_law.pcm
Only in wanec/buffers: voice_long_u_law.pcm
Only in wanec.old/: build.sh
Only in wanec: CVS
Only in wanec: image
Only in wanec/lib: CVS
Binary files wanec.old/lib/liboct6100api.a and wanec/lib/liboct6100api.a differ
diff -dur wanec.old/Makefile wanec/Makefile
--- wanec.old/Makefile	2006-10-06 14:47:58.000000000 -0400
+++ wanec/Makefile	2006-10-27 14:01:05.675185024 -0400
@@ -1,53 +1,226 @@
-# Makefile for hello world kernel 2.6 module.              -*-makefile-*-
-#
-# Copyright (C) 2004 Joachim Nilsson <joachim.nilsson@member.fsf.org>
-#
-# Licensed under the GNU General Public License, v2.0 or later,
-# at your option.  See the file COPYING for details, or the web
-# page http://www.gnu.org/copyleft/gpl.html
+# ============================================================================
+# Makefile	Multiprotocol WAN Router for Linux.  Make Script.
 #
+# Copyright	(c) 1995-1997 Sangoma Technologies Inc.  All Rights Reserved.
+# ----------------------------------------------------------------------------
+# Mar 27  2000  Nenad Corbic	Version 2.0.5 to 2.1.2
+# Jan 07, 1999	Jaspreet Singh	Version 2.0.4
+# Aug 25, 1998	Jaspreet Singh  Version 2.0.3
+# Nov 06, 1997	Jaspreet Singh	Version 2.0.0
+# Jul 28, 1997	Jaspreet Singh  Version 1.0.5
+# Jul 10, 1997  Jaspreet Singh	Version 1.0.4
+# June 3, 1997	Jaspreet Singh	Version 1.0.3	
+# Jan 15, 1997	Gene Kozin	Version 1.0.1.
+# Dec 31, 1996	Gene Kozin	Initial version.
+# ============================================================================
 
-OBJS = 
-MODULE_NAME = 
-EXTRA_CFLAGS = 
-KDIR =	
-$(MODULE_NAME)-objs = $(OBJS)
+####### DEFINES ##############################################################
 
-RM      = @rm -rf
-JUNK	= *~ *.bak DEADJOE
+ARCH=$(shell uname -m)
+
+OUTDIR  = mod
+TMPDIR  = tmp
+MODDIR  = modinfo
 
+KERN := $(shell grep 2.4 /usr/src/linux/include/linux/version.h)
+KERN_V26 := $(shell grep 2.6 /usr/src/linux/include/linux/version.h)
 
-# First pass, kernel Makefile reads module objects
-ifneq ($(KERNELRELEASE),)
-obj-m	:= $(MODULE_NAME).o
+BTDIR		= oct6100_api/apilib/bt
+LARGMATHDIR	= oct6100_api/apilib/largmath
+LLMANDIR	= oct6100_api/apilib/llman
+OCTAPIDIR	= oct6100_api/octdeviceapi/oct6100api/oct6100_api
+OCTAPIMIDIR	= oct6100_api/octdeviceapi/oct6100api/oct6100_apimi
 
+ifneq "${KERN}" ""
+
+MODTYPE=o
+K_WAN_DIR=drivers/net/wan
 
-# Second pass, the actual build.
 else
-KVER    ?= $(shell uname -r)
-PWD	:= $(shell pwd)
-KBUILD_VERBOSE=
-	
-all:
-	$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) CC=$(CC) KBUILD_VERBOSE=$(KBUILD_VERBOSE) modules
 
-clean:
-	$(shell find  . -name '*.*o'  | xargs rm)
-	$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) clean
+ifneq "${KERN_V26}" ""
 
-distclean: clean
-	$(RM) $(JUNK) $(OBJS)
+ifeq "${ARCH}" "x86_64"
+#LDFLAGS=-m elf_x86_64
+LD_ELF=-m elf_x86_64
+else
+#LDFLAGS=-m elf_i386
+LD_ELF=-m elf_i386
+endif
 
-help:
-	$(MAKE) -C $(KDIR) SUBDIRS=$(PWD) help
 
+MODTYPE=ko
+K_WAN_DIR=drivers/net/wan
 
-# Indents the kernel source the way linux/Documentation/CodingStyle.txt
-# wants it to be.
-indent:
-	indent -kr -i8 $($(MODULE_NAME)-objs:.o=.c)
+else
 
-install:
-	$(MAKE) -C $(KDIR) M=$(PWD) modules_install
+MODTYPE=o
+K_WAN_DIR=drivers/net
+
+endif
 
 endif
+
+CFLAGS =  $(shell cat /wanpipe/GCFLAGS)
+CFLAGS += -I. -Ioct6100_api -Ioct6100_api/include				\
+		-Ioct6100_api/include  -Ioct6100_api/include/apilib		\
+		-Ioct6100_api/include/apilib -Ioct6100_api/include/octrpc	\
+		-Ioct6100_api/include/oct6100api				\
+		-Ioct6100_api/octdeviceapi/oct6100api
+
+CFLAGS += -DENABLE_TONE_PLAY -I/usr/include/wanpipe
+
+#CFLAGS=-Wp,-MD,.wanpipe_lip.o.d -nostdinc -iwithprefix include -D__KERNEL__ -D__LINUX__ -Iinclude -I/usr/src/linux/include  -Wall -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -pipe -mpreferred-stack-boundary=2 -march=$(ARCH) -I/usr/src/linux/include/asm-i386/mach-default -O2  -DWANLIP_DRIVER -DMODULE
+
+#CFLAGS+= -DCONFIG_PRODUCT_WANPIPE_FR -DCONFIG_PRODUCT_WANPIPE_CHDLC -DCONFIG_PRODUCT_WANPIPE_PPP -DCONFIG_PRODUCT_WANPIPE_XDLC -DCONFIG_PRODUCT_WANPIPE_LAPB -DCONFIG_PRODUCT_WANPIPE_XMTP2
+
+####### RULES ################################################################
+
+all:	$(OUTDIR)/wanec.$(MODTYPE)
+	@echo "Ok."
+
+$(OUTDIR)/wanec.ko: $(OUTDIR)/wanec.o $(MODDIR)/wanec.mod.o
+	ld $(LD_ELF) -r -o $@ $^
+	chmod 664 $@
+
+$(MODDIR)/wanec.mod.o:	$(MODDIR)/wanec.mod.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=wanec -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+#----------------------------------------------------
+
+$(OUTDIR)/wanec.o: $(TMPDIR)/wanec_iface.o  $(TMPDIR)/wanec_cmd.o $(TMPDIR)/wanec_utils.o $(TMPDIR)/wanec_dev.o $(TMPDIR)/octapi_bt0.o $(TMPDIR)/octapi_largmath.o $(TMPDIR)/octapi_llman.o $(TMPDIR)/oct6100_mask_interrupts.o $(TMPDIR)/oct6100_adpcm_chan.o $(TMPDIR)/oct6100_channel.o $(TMPDIR)/oct6100_chip_open.o $(TMPDIR)/oct6100_chip_stats.o $(TMPDIR)/oct6100_conf_bridge.o  $(TMPDIR)/oct6100_debug.o $(TMPDIR)/oct6100_events.o $(TMPDIR)/oct6100_interrupts.o $(TMPDIR)/oct6100_memory.o $(TMPDIR)/oct6100_miscellaneous.o $(TMPDIR)/oct6100_mixer.o $(TMPDIR)/oct6100_phasing_tsst.o $(TMPDIR)/oct6100_playout_buf.o $(TMPDIR)/oct6100_remote_debug.o $(TMPDIR)/oct6100_tlv.o $(TMPDIR)/oct6100_tone_detection.o $(TMPDIR)/oct6100_tsi_cnct.o $(TMPDIR)/oct6100_tsst.o $(TMPDIR)/oct6100_user.o
+	ld $(LD_ELF) -r -o $@ $^
+	chmod 664 $@
+
+
+#-----------------------------------------------------
+
+$(TMPDIR)/wanec_main.o:			wanec_main.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=wanec_main -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/wanec_iface.o:			wanec_iface.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=wanec_iface -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/wanec_cmd.o:			wanec_cmd.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=wanec_cmd -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/wanec_utils.o:		wanec_utils.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=wanec_utils -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/wanec_dev.o:			wanec_dev.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=wanec_dev -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/octapi_bt0.o:			$(BTDIR)/octapi_bt0.c
+	$(CC) $(CFLAGS) -I$(BT)  -DKBUILD_BASENAME=octapi_bt0 -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/octapi_largmath.o:		$(LARGMATHDIR)/octapi_largmath.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=octapi_largmath -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/octapi_llman.o:		$(LLMANDIR)/octapi_llman.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=octapi_llman -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_mask_interrupts.o:	$(OCTAPIMIDIR)/oct6100_mask_interrupts.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_mask_interrupts -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_adpcm_chan.o:		$(OCTAPIDIR)/oct6100_adpcm_chan.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_adpcm_chan -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_channel.o:		$(OCTAPIDIR)/oct6100_channel.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_channel -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_chip_open.o:		$(OCTAPIDIR)/oct6100_chip_open.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_chip_open -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_chip_stats.o:		$(OCTAPIDIR)/oct6100_chip_stats.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_chip_stats -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_conf_bridge.o:	$(OCTAPIDIR)/oct6100_conf_bridge.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_conf_bridge -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_debug.o:	$(OCTAPIDIR)/oct6100_debug.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_debug -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_events.o:	$(OCTAPIDIR)/oct6100_events.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_events -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_interrupts.o:	$(OCTAPIDIR)/oct6100_interrupts.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_interrupts -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_memory.o:	$(OCTAPIDIR)/oct6100_memory.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_memory -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_miscellaneous.o:	$(OCTAPIDIR)/oct6100_miscellaneous.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_miscellaneous -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_oct6100_debug.o:	$(OCTAPIDIR)/oct6100_oct6100_debug.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_oct6100_debug -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_mixer.o:	$(OCTAPIDIR)/oct6100_mixer.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_mixer -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_phasing_tsst.o:	$(OCTAPIDIR)/oct6100_phasing_tsst.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_phasing_tsst -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_playout_buf.o:	$(OCTAPIDIR)/oct6100_playout_buf.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_playout_buf -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_remote_debug.o:	$(OCTAPIDIR)/oct6100_remote_debug.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_remote_debug -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_tlv.o:	$(OCTAPIDIR)/oct6100_tlv.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_tlv -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_tone_detection.o:	$(OCTAPIDIR)/oct6100_tone_detection.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_tone_detection -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_tsi_cnct.o:	$(OCTAPIDIR)/oct6100_tsi_cnct.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_tsi_cnt -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_tsst.o:	$(OCTAPIDIR)/oct6100_tsst.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_tsst -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+$(TMPDIR)/oct6100_user.o:	$(OCTAPIDIR)/oct6100_user.c
+	$(CC) $(CFLAGS) -DKBUILD_BASENAME=oct6100_user -DKBUILD_MODNAME=wanec -c -o $@ $^
+	chmod 664 $@
+
+clean:
+	rm -f wanec.$(MODTYPE)
+	rm -f *.o*
+	rm -f mod/*.*o
+	rm -f tmp/*.*o
+	rm -f modinfo/*.*o
+
+install:
+	install -D $(OUTDIR)/wanec.${MODTYPE} /lib/modules/$(shell uname -r)/kernel/net/wanrouter/wanec.${MODTYPE}
+
+uninstall:
+	rm -f /lib/modules/$(shell uname -r)/kernel/net/wanrouter/wanec.${MODTYPE}
Only in wanec: Makefile5.FreeBSD
Only in wanec: Makefile6.FreeBSD
Only in wanec: Makefile.FreeBSD
Only in wanec: Makefile.kernel
Only in wanec: Makefile.Linux
Only in wanec: Makefile.OpenBSD
Only in wanec: Makefile_test
Only in wanec/mod: CVS
Only in wanec/mod: wanec.ko
Only in wanec/mod: wanec.o
Only in wanec/modinfo: CVS
Only in wanec/modinfo: wanec.mod.o
Only in wanec.old/: Module.symvers
Only in wanec/oct6100_api/apilib/bt: CVS
Only in wanec/oct6100_api/apilib/bt: makefile
Only in wanec.old/oct6100_api/apilib/bt: .octapi_bt0.o.cmd
Only in wanec/oct6100_api/apilib/bt: sources
Only in wanec/oct6100_api/apilib: CVS
Only in wanec/oct6100_api/apilib/largmath: CVS
Only in wanec/oct6100_api/apilib/largmath: makefile
Only in wanec.old/oct6100_api/apilib/largmath: .octapi_largmath.o.cmd
Only in wanec/oct6100_api/apilib/largmath: sources
Only in wanec/oct6100_api/apilib/llman: CVS
Only in wanec/oct6100_api/apilib/llman: makefile
Only in wanec.old/oct6100_api/apilib/llman: .octapi_llman.o.cmd
Only in wanec/oct6100_api/apilib/llman: sources
Only in wanec/oct6100_api: CVS
Only in wanec/oct6100_api/include/apilib: CVS
Only in wanec/oct6100_api/include: CVS
Only in wanec/oct6100_api/include/oct6100api: CVS
diff -dur wanec.old/oct6100_api/include/octosdependant.h wanec/oct6100_api/include/octosdependant.h
--- wanec.old/oct6100_api/include/octosdependant.h	2006-10-06 14:46:50.000000000 -0400
+++ wanec/oct6100_api/include/octosdependant.h	2006-10-27 14:01:07.369927384 -0400
@@ -1,155 +1,159 @@
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-File: octosdependant.h
-
-    Copyright (c) 2001-2006 Octasic Inc.
-
-Description: 
-
-	This file is included to set target-specific constants.
-
-This file is part of the Octasic OCT6100 GPL API . The OCT6100 GPL API  is 
-free software; you can redistribute it and/or modify it under the terms of 
-the GNU General Public License as published by the Free Software Foundation; 
-either version 2 of the License, or (at your option) any later version.
-
-The OCT6100 GPL API is distributed in the hope that it will be useful, but 
-WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
-or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
-for more details. 
-
-You should have received a copy of the GNU General Public License 
-along with the OCT6100 GPL API; if not, write to the Free Software 
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-
-$Octasic_Release: OCT612xAPI-01.00-PR43 $
-
-$Octasic_Revision: 16 $
-
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-
-#ifndef __OCTOSDEPENDANT_H__
-#define __OCTOSDEPENDANT_H__
-
-
-/*--------------------------------------------------------------------------
-	C language
-----------------------------------------------------------------------------*/
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-
-/*****************************************************************************
-
-  Known define values
-
-	MSDEV:
-			WIN32		==	WINDOWS 32 bit app
-			__WIN32__	==	WINDOWS 32 bit app
-			_Windows	==	WINDOWS 16 bit app
-
-			_WINDOWS	==	Windows application .. not console
-			_DLL		==	Dll Application
-			_CONSOLE	==	Console Application .. no windows
-
-	BORLANDC
-			__TURBOC__		== Turbo Compiler
-			__BORLANDC__	== Borland compiler
-			__OS2__			== Borland OS2 compiler
-			_Windows		== Windows 16 bit app
-
-	GCC Compiler
-			__GNUC__		== GCC Compiler
-			__unix__		== Unix system 
-			__vax__			== Unix system 
-			unix			== Unix system
-			vax				== vax system
-
-	TORNADO
-			_VXWORKS_		==	VXWORK
-
-	ECOS/CYGWIN
-			_ECOS_			== eCos
-
-  	SOLARIS
-			_SOLARIS_		== Solaris
-
-*****************************************************************************/
-
-/* Machine endian type */
-
-#define OCT_MACH_LITTLE_ENDIAN		1
-#define OCT_MACH_BIG_ENDIAN			2
-
-/* Try to find current OCT_MACH_ENDIAN from compiler define values */
-#if !defined( MACH_TYPE_BIG_ENDIAN ) && !defined( MACH_TYPE_LITTLE_ENDIAN )
-
-	/* Look for intel */
-	#if defined( _M_IX86 )	
-		#define OCT_MACH_ENDIAN		OCT_MACH_LITTLE_ENDIAN
-	/* Look for PowerPC */
-	#elif defined( _M_MPPC  ) || defined( _M_PPC ) 
-		#define OCT_MACH_ENDIAN		OCT_MACH_BIG_ENDIAN
-	#elif defined( CPU )
-		#if CPU==PPC860 || CPU==SIMNT
-			#define OCT_MACH_ENDIAN		OCT_MACH_BIG_ENDIAN
-		#else
-			#define OCT_MACH_ENDIAN		OCT_MACH_LITTLE_ENDIAN	
-		#endif
-	/* Default is little endian */
-	#else
-		#define OCT_MACH_ENDIAN		OCT_MACH_LITTLE_ENDIAN	
-	#endif
-#else
-	#if defined( MACH_TYPE_BIG_ENDIAN )
-		#define OCT_MACH_ENDIAN		OCT_MACH_BIG_ENDIAN
-	#else
-		#define OCT_MACH_ENDIAN		OCT_MACH_LITTLE_ENDIAN	
-	#endif
-#endif
-
-/* Find system type if not already defined */
-#if !defined( OCT_NTDRVENV ) && !defined( OCT_VXENV ) && !defined( OCT_WINENV )
-
-#if defined( WIN32 ) || defined( __WIN32__ ) ||	defined( _WIN32_ ) || defined( WIN32S )
-	/* Verif if building a win32 driver */
-	#if ( defined( WIN32 ) && WIN32==100 )
-		#define OCT_NTDRVENV
-	#else
-		#define OCT_WINENV
-	#endif
-#elif defined( _VXWORKS_ )
-	#define OCT_VXENV
-#elif defined( _ECOS_ )
-	#define OCT_ECOSENV
-#elif defined( _SOLARIS_ )
-	#define OCT_SOLARISENV
-#elif defined( _LINUX_ )
-	#define OCT_LINUXENV
-#else
-	/* Unknown environment */
-	#define OCT_UNKNOWNENV
-#endif	/* WIN env */
-
-#endif /* Already defined */
-
-#if defined( __KERNEL__ ) && defined( OCT_LINUXENV )
-#define OCT_LINUXDRVENV
-#endif
-
-#ifdef _DEBUG
-#define OCT_OPT_USER_DEBUG
-#endif
-
-/*--------------------------------------------------------------------------
-	C language
-----------------------------------------------------------------------------*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif	/* __OCTOSDEPENDANT_H__ */
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+File: octosdependant.h
+
+    Copyright (c) 2001-2006 Octasic Inc.
+
+Description: 
+
+	This file is included to set target-specific constants.
+
+This file is part of the Octasic OCT6100 GPL API . The OCT6100 GPL API  is 
+free software; you can redistribute it and/or modify it under the terms of 
+the GNU General Public License as published by the Free Software Foundation; 
+either version 2 of the License, or (at your option) any later version.
+
+The OCT6100 GPL API is distributed in the hope that it will be useful, but 
+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
+or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
+for more details. 
+
+You should have received a copy of the GNU General Public License 
+along with the OCT6100 GPL API; if not, write to the Free Software 
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+
+$Octasic_Release: OCT612xAPI-01.00-PR43 $
+
+$Octasic_Revision: 16 $
+
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+
+#ifndef __OCTOSDEPENDANT_H__
+#define __OCTOSDEPENDANT_H__
+
+
+/*--------------------------------------------------------------------------
+	C language
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+/*****************************************************************************
+
+  Known define values
+
+	MSDEV:
+			WIN32		==	WINDOWS 32 bit app
+			__WIN32__	==	WINDOWS 32 bit app
+			_Windows	==	WINDOWS 16 bit app
+
+			_WINDOWS	==	Windows application .. not console
+			_DLL		==	Dll Application
+			_CONSOLE	==	Console Application .. no windows
+
+	BORLANDC
+			__TURBOC__		== Turbo Compiler
+			__BORLANDC__	== Borland compiler
+			__OS2__			== Borland OS2 compiler
+			_Windows		== Windows 16 bit app
+
+	GCC Compiler
+			__GNUC__		== GCC Compiler
+			__unix__		== Unix system 
+			__vax__			== Unix system 
+			unix			== Unix system
+			vax				== vax system
+
+	TORNADO
+			_VXWORKS_		==	VXWORK
+
+	ECOS/CYGWIN
+			_ECOS_			== eCos
+
+  	SOLARIS
+			_SOLARIS_		== Solaris
+
+*****************************************************************************/
+
+/* Machine endian type */
+
+#define OCT_MACH_LITTLE_ENDIAN		1
+#define OCT_MACH_BIG_ENDIAN			2
+
+/* Try to find current OCT_MACH_ENDIAN from compiler define values */
+#if !defined( MACH_TYPE_BIG_ENDIAN ) && !defined( MACH_TYPE_LITTLE_ENDIAN )
+
+	/* Look for intel */
+	#if defined( _M_IX86 )	
+		#define OCT_MACH_ENDIAN		OCT_MACH_LITTLE_ENDIAN
+	/* Look for PowerPC */
+	#elif defined( _M_MPPC  ) || defined( _M_PPC ) 
+		#define OCT_MACH_ENDIAN		OCT_MACH_BIG_ENDIAN
+	#elif defined( CPU )
+		#if CPU==PPC860 || CPU==SIMNT
+			#define OCT_MACH_ENDIAN		OCT_MACH_BIG_ENDIAN
+		#else
+			#define OCT_MACH_ENDIAN		OCT_MACH_LITTLE_ENDIAN	
+		#endif
+	/* Default is little endian */
+	#else
+		#define OCT_MACH_ENDIAN		OCT_MACH_LITTLE_ENDIAN	
+	#endif
+#else
+	#if defined( MACH_TYPE_BIG_ENDIAN )
+		#define OCT_MACH_ENDIAN		OCT_MACH_BIG_ENDIAN
+	#else
+		#define OCT_MACH_ENDIAN		OCT_MACH_LITTLE_ENDIAN	
+	#endif
+#endif
+
+/* Find system type if not already defined */
+#if !defined( OCT_NTDRVENV ) && !defined( OCT_VXENV ) && !defined( OCT_WINENV )
+
+#if defined( WIN32 ) || defined( __WIN32__ ) ||	defined( _WIN32_ ) || defined( WIN32S )
+	/* Verif if building a win32 driver */
+	#if ( defined( WIN32 ) && WIN32==100 )
+		#define OCT_NTDRVENV
+	#else
+		#define OCT_WINENV
+	#endif
+#elif defined( _VXWORKS_ )
+	#define OCT_VXENV
+#elif defined( _ECOS_ )
+	#define OCT_ECOSENV
+#elif defined( _SOLARIS_ )
+	#define OCT_SOLARISENV
+#elif defined( _LINUX_ )
+	#define OCT_LINUXENV
+#else
+	/* Unknown environment */
+	#define OCT_UNKNOWNENV
+#endif	/* WIN env */
+
+#endif /* Already defined */
+
+#if defined(__WINDOWS__)
+#define OCT_NTDRVENV
+#endif
+
+#if defined( __KERNEL__ ) && defined( OCT_LINUXENV )
+#define OCT_LINUXDRVENV
+#endif
+
+#ifdef _DEBUG
+#define OCT_OPT_USER_DEBUG
+#endif
+
+/*--------------------------------------------------------------------------
+	C language
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* __OCTOSDEPENDANT_H__ */
Only in wanec/oct6100_api/include/octrpc: CVS
diff -dur wanec.old/oct6100_api/include/octtype.h wanec/oct6100_api/include/octtype.h
--- wanec.old/oct6100_api/include/octtype.h	2006-10-06 14:46:50.000000000 -0400
+++ wanec/oct6100_api/include/octtype.h	2006-10-27 14:01:07.369927384 -0400
@@ -1,153 +1,157 @@
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-File: octtype.h
-
-    Copyright (c) 2001-2006 Octasic Inc.
-
-Description: 
-
-	This file defines the base storage types.
-
-This file is part of the Octasic OCT6100 GPL API . The OCT6100 GPL API  is 
-free software; you can redistribute it and/or modify it under the terms of 
-the GNU General Public License as published by the Free Software Foundation; 
-either version 2 of the License, or (at your option) any later version.
-
-The OCT6100 GPL API is distributed in the hope that it will be useful, but 
-WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
-or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
-for more details. 
-
-You should have received a copy of the GNU General Public License 
-along with the OCT6100 GPL API; if not, write to the Free Software 
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-
-$Octasic_Release: OCT612xAPI-01.00-PR43 $
-
-$Octasic_Revision: 18 $
-
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-#ifndef __OCTTYPE_H__
-#define __OCTTYPE_H__
-
-/*--------------------------------------------------------------------------
-	C language
-----------------------------------------------------------------------------*/
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*--------------------------------------------------------------------------
-	Include target-specific header if available 
-----------------------------------------------------------------------------*/
-#if defined( OCT_NTDRVENV )
-	#include "octtypentdrv.h"		/* All NT driver typedef */
-#elif defined( OCT_WINENV )	
-	#include "octtypewin.h"			/* All Win32 typedef */
-#elif defined( OCT_VXENV )
-	#include "octtypevx.h"			/* All VxWorks typedef */
-#else
-/*--------------------------------------------------------------------------
-	No target-specific header  available 
-----------------------------------------------------------------------------*/
-
-/*****************************  DEFINES  *************************************/
-/* 16-bit integer */
-typedef unsigned short	UINT16;
-typedef signed short	INT16;
-typedef unsigned short	*PUINT16;
-typedef signed short	*PINT16;
-
-/* 8-bit integer */
-typedef unsigned char	UINT8;
-typedef signed char		INT8;
-typedef signed char		OCT_INT8;
-typedef unsigned char	*PUINT8;
-typedef signed char		*PINT8;
-
-
-/* 32 bit integer */
-typedef unsigned int	UINT32;
-typedef signed int		INT32;
-typedef INT32 *			PINT32;
-typedef UINT32 *		PUINT32;
-
-/* Long integer */
-typedef signed long		LONG;
-typedef unsigned long	ULONG;
-typedef	long *			PLONG;
-typedef	unsigned long *	PULONG;
-
-/* Short integer */
-typedef	short			SHORT;
-typedef	unsigned short	USHORT;
-typedef	short *			PSHORT;
-typedef	unsigned short *PUSHORT;
-
-/* 8-bit integer*/
-typedef unsigned char	BYTE;
-typedef	BYTE *			PBYTE;
-typedef unsigned char	UCHAR;
-
-/* Character and strings */
-typedef char			CHAR;
-typedef	CHAR 			SZ;
-typedef	CHAR *			PSZ;
-typedef	CHAR *			PCHAR;
-
-/* Double integers */
-typedef	double			DOUBLE;
-typedef	double *		PDOUBLE;
-typedef	float			FLOAT;
-typedef	float *			PFLOAT;
-
-typedef	void			VOID;
-typedef	void *			PVOID;
-
-/* Booleans */
-typedef	int				BOOL;
-typedef	BOOL *			PBOOL;
-
-/* Integers */
-typedef	int				INT;
-typedef	int *			PINT;
-typedef	unsigned int	UINT;
-typedef	unsigned int *	PUINT;
-
-/* Define pseudo-keywords IN and OUT if not defined yet */
-#ifndef IN
-#define IN		/* IN param */
-#endif
-
-#ifndef OUT
-#define OUT		/* OUT param */
-#endif
-
-/* LONG LONG */
-#define LLONG			signed long long
-#define PLLONG			signed long long *
-#define ULLONG			unsigned long long
-#define PULLONG			unsigned long long *
-
-#ifndef OPT
-#define OPT		/* OPT param */
-#endif
-
-typedef	PSZ *	PPSZ;
-
-#ifndef NULL
-#define NULL 0
-#endif
-
-#endif
-
-/*--------------------------------------------------------------------------
-	C language
-----------------------------------------------------------------------------*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif	/* __OCTTYPE_H__ */
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+File: octtype.h
+
+    Copyright (c) 2001-2006 Octasic Inc.
+
+Description: 
+
+	This file defines the base storage types.
+
+This file is part of the Octasic OCT6100 GPL API . The OCT6100 GPL API  is 
+free software; you can redistribute it and/or modify it under the terms of 
+the GNU General Public License as published by the Free Software Foundation; 
+either version 2 of the License, or (at your option) any later version.
+
+The OCT6100 GPL API is distributed in the hope that it will be useful, but 
+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
+or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
+for more details. 
+
+You should have received a copy of the GNU General Public License 
+along with the OCT6100 GPL API; if not, write to the Free Software 
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+
+$Octasic_Release: OCT612xAPI-01.00-PR43 $
+
+$Octasic_Revision: 18 $
+
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+#ifndef __OCTTYPE_H__
+#define __OCTTYPE_H__
+
+/*--------------------------------------------------------------------------
+	C language
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*--------------------------------------------------------------------------
+	Include target-specific header if available 
+----------------------------------------------------------------------------*/
+#if defined( OCT_NTDRVENV )
+	#include "octtypentdrv.h"		/* All NT driver typedef */
+#elif defined( OCT_WINENV )	
+	#include "octtypewin.h"			/* All Win32 typedef */
+#elif defined( OCT_VXENV )
+	#include "octtypevx.h"			/* All VxWorks typedef */
+//#else
+#endif
+/*--------------------------------------------------------------------------
+	No target-specific header  available 
+----------------------------------------------------------------------------*/
+
+/*****************************  DEFINES  *************************************/
+/* 16-bit integer */
+typedef unsigned short	UINT16;
+typedef signed short	INT16;
+typedef unsigned short	*PUINT16;
+typedef signed short	*PINT16;
+
+/* 8-bit integer */
+typedef unsigned char	UINT8;
+typedef signed char		INT8;
+typedef signed char		OCT_INT8;
+typedef unsigned char	*PUINT8;
+typedef signed char		*PINT8;
+
+
+/* 32 bit integer */
+typedef unsigned int	UINT32;
+typedef signed int		INT32;
+typedef INT32 *			PINT32;
+typedef UINT32 *		PUINT32;
+
+/* Long integer */
+typedef signed long		LONG;
+typedef unsigned long	ULONG;
+typedef	long *			PLONG;
+typedef	unsigned long *	PULONG;
+
+/* Short integer */
+typedef	short			SHORT;
+typedef	unsigned short	USHORT;
+typedef	short *			PSHORT;
+typedef	unsigned short *PUSHORT;
+
+/* 8-bit integer*/
+typedef unsigned char	BYTE;
+typedef	BYTE *			PBYTE;
+typedef unsigned char	UCHAR;
+
+/* Character and strings */
+typedef char			CHAR;
+typedef	CHAR 			SZ;
+typedef	CHAR *			PSZ;
+typedef	CHAR *			PCHAR;
+
+/* Double integers */
+typedef	double			DOUBLE;
+typedef	double *		PDOUBLE;
+typedef	float			FLOAT;
+typedef	float *			PFLOAT;
+
+#if !defined(__WINDOWS__) 
+typedef	void			VOID;
+#else
+#define VOID			void
+#endif
+typedef	void *			PVOID;
+
+/* Booleans */
+typedef	int				BOOL;
+typedef	BOOL *			PBOOL;
+
+/* Integers */
+typedef	int				INT;
+typedef	int *			PINT;
+typedef	unsigned int	UINT;
+typedef	unsigned int *	PUINT;
+
+/* Define pseudo-keywords IN and OUT if not defined yet */
+#ifndef IN
+#define IN		/* IN param */
+#endif
+
+#ifndef OUT
+#define OUT		/* OUT param */
+#endif
+
+/* LONG LONG */
+#define LLONG			signed long long
+#define PLLONG			signed long long *
+#define ULLONG			unsigned long long
+#define PULLONG			unsigned long long *
+
+#ifndef OPT
+#define OPT		/* OPT param */
+#endif
+
+typedef	PSZ *	PPSZ;
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+
+/*--------------------------------------------------------------------------
+	C language
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* __OCTTYPE_H__ */
Only in wanec/oct6100_api/include: octtypentdrv.h
Only in wanec/oct6100_api/octdeviceapi: CVS
Only in wanec/oct6100_api/octdeviceapi/oct6100api: CVS
Only in wanec/oct6100_api/octdeviceapi/oct6100api/oct6100_api: CVS
Only in wanec/oct6100_api/octdeviceapi/oct6100api/oct6100_api: makefile
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_adpcm_chan.o.cmd
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_channel.o.cmd
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_chip_open.o.cmd
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_chip_stats.o.cmd
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_conf_bridge.o.cmd
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_debug.o.cmd
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_events.o.cmd
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_interrupts.o.cmd
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_memory.o.cmd
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_miscellaneous.o.cmd
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_mixer.o.cmd
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_phasing_tsst.o.cmd
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_playout_buf.o.cmd
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_remote_debug.o.cmd
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_tlv.o.cmd
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_tone_detection.o.cmd
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_tsi_cnct.o.cmd
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_tsst.o.cmd
diff -dur wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api/oct6100_user.c wanec/oct6100_api/octdeviceapi/oct6100api/oct6100_api/oct6100_user.c
--- wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api/oct6100_user.c	2006-10-06 14:46:50.000000000 -0400
+++ wanec/oct6100_api/octdeviceapi/oct6100api/oct6100_api/oct6100_user.c	2006-10-27 14:01:07.383925256 -0400
@@ -1,1043 +1,1109 @@
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-File: oct6100_user.c
-
-	Copyright (c) 2001 Octasic Inc. All rights reserved.
-    
-Description: 
-
-	This file contains the functions provided by the user.
-
-This source code is Octasic Confidential. Use of and access to this code
-is covered by the Octasic Device Enabling Software License Agreement. 
-Acknowledgement of the Octasic Device Enabling Software License was 
-required for access to this code. A copy was also provided with the release.
-
-
-$Octasic_Release: OCT612xAPI-01.00-PR37 $
-
-$Octasic_Revision: 25 $
-
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-
-
-/*****************************  INCLUDE FILES  *******************************/
-
-
-/* System specific includes */
-#if defined(WAN_EC_USER)
-# include <unistd.h>
-# include <stdio.h>
-# include <stdlib.h>
-# include <time.h>
-# include <sys/fcntl.h>
-# include <sys/time.h>
-# include <sys/stat.h>
-# include <sys/types.h>
-# include <sys/ipc.h>
-# include <sys/sem.h>
-# include <sys/queue.h>
-# include <getopt.h>
-# include <limits.h>
-# include <errno.h>
-# include <memory.h>
-# include <signal.h>
-# include <semaphore.h>
-# include <sys/ioctl.h>
-# if defined(__LINUX__)
-#  include <linux/wanpipe_defines.h>
-#  include <linux/wanpipe_cfg.h>
-# elif defined(__FreeBSD__) || defined(__OpenBSD__)
-#  include <net/wanpipe_defines.h>
-#  include <net/wanpipe_cfg.h>
-# endif
-# include "oct6100api/oct6100_apiud.h"
-# include "oct6100api/oct6100_errors.h"
-# include "oct6100api/oct6100_api.h"
-# include "oct6100_version.h"
-# include "wanec_iface.h"
-#else
-# if defined(__LINUX__)
-#  include <linux/wanpipe_includes.h>
-#  include <linux/wanpipe.h>
-# else
-#  include <wanpipe_includes.h>
-#  include <wanpipe.h>
-# endif
-
-#include "oct6100api/oct6100_apiud.h"
-#include "oct6100api/oct6100_errors.h"
-
-#include "oct6100api/oct6100_api.h"
-#include "oct6100_version.h"
-
-# include "wanec_iface.h"
-#endif
-
-extern u_int32_t wanec_req_write(void*, u_int32_t write_addr, u_int16_t write_data);
-extern u_int32_t wanec_req_write_smear(void*, u_int32_t addr, u_int16_t data, u_int32_t len);
-extern u_int32_t wanec_req_write_burst(void*, u_int32_t addr, u_int16_t *data, u_int32_t len);
-extern u_int32_t wanec_req_read(void*, u_int32_t addr, u_int16_t *data);
-extern u_int32_t wanec_req_read_burst(void*, u_int32_t addr, u_int16_t *data, u_int32_t len);
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserGetTime
-
-Description:	Returns the system time in us.
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN OUT f_pTime		Pointer to structure in which the time is returned.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserGetTime(
-
-			IN OUT tPOCT6100_GET_TIME	f_pTime )
-{
-	clock_t		ulClockTicks;
-	struct timeval	TimeVal;
-	static UINT32	ulWallTimeUsHigh = 0;
-	static UINT32	ulWallTimeUsLow = 0;
-
-	if( !f_pTime )
-		return cOCT6100_GET_TIME_FAILED_0;
-
-	/* Retrieve clock tick */
-#if defined(WAN_KERNEL)
-	wan_getcurrenttime( &TimeVal.tv_sec, &TimeVal.tv_usec );
-#else
-	gettimeofday( &TimeVal, NULL );
-#endif
-	/* ulClockTicks = ( TimeVal.tv_sec * 1000000 ) + ( TimeVal.tv_usec ); */
-	/* Create a value im ms (as clock does) */
-	ulClockTicks = ( TimeVal.tv_sec * 1000 ) + ( TimeVal.tv_usec /1000 );
-
-	/* move to micro sec */
-	ulClockTicks *= 1000;
-
-	/* Did it wrap ? */
-	if ( (UINT32)ulClockTicks < ulWallTimeUsLow )
-	{
-		/* Yes, so increment MSB */
-		ulWallTimeUsHigh++;
-	}
-
-	f_pTime->aulWallTimeUs[ 0 ] = ulClockTicks;
-	f_pTime->aulWallTimeUs[ 1 ] = ulWallTimeUsHigh;
-	ulWallTimeUsLow = f_pTime->aulWallTimeUs[ 0 ];
-
-	return cOCT6100_ERR_OK;
-}
-
-
-
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserMemSet
-
-Description:	Sets f_ulLength bytes pointed to by f_pAddress to f_ulPattern.
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserMemSet(
-			IN	PVOID	f_pAddress,
-			IN	UINT32	f_ulPattern,
-			IN	UINT32	f_ulLength )
-{
-
-	memset( f_pAddress, f_ulPattern, f_ulLength );
-
-	return cOCT6100_ERR_OK;
-}
-
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserMemCopy
-
-Description:	Copy f_ulLength bytes from f_pSource to f_pDestination.
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserMemCopy(
-			IN	PVOID	f_pDestination,
-			IN	PVOID	f_pSource,
-			IN	UINT32	f_ulLength )
-{
-
-	memcpy( f_pDestination, f_pSource, f_ulLength );
-
-	return cOCT6100_ERR_OK;
-}
-
-
-#if !defined(WAN_KERNEL)
-static void SigArlmHandler()
-{
-}
-#endif
-
-#if defined(__GNU_LIBRARY__) && !defined(_SEM_SEMUN_UNDEFINED) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(WAN_KERNEL)
-/* union semun is defined by including <sys/sem.h> */
-#else
-/* according to X/OPEN we have to define it ourselves */
-union semun {
-	int val;                  /* value for SETVAL */
-	struct semid_ds *buf;     /* buffer for IPC_STAT, IPC_SET */
-	unsigned short *array;    /* array for GETALL, SETALL */
-                              /* Linux specific part: */
-	struct seminfo *__buf;    /* buffer for IPC_INFO */
-};
-#endif
-
-typedef struct _SEM_FILE_INF_
-{
-	UINT32		ulMainProcessId;
-	UINT32		ulUsageCount;
-
-} tSEM_FILE_INF, *tPSEM_FILE_INF;
-
-typedef struct _SEM_INF_
-{
-	INT			SemId;
-	CHAR		szFileName[PATH_MAX];
-
-} tSEM_INF, *tPSEM_INF;
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserCreateSerializeObject
-
-Description:	Creates a serialization object. The serialization object is
-				seized via the Oct6100UserSeizeSerializeObject function.
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN OUT f_pCreate		Pointer to structure in which the serialization object's
-				handle is returned.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserCreateSerializeObject(
-
-		IN OUT tPOCT6100_CREATE_SERIALIZE_OBJECT	f_pCreate )
-{
-
-#if !defined(WAN_KERNEL)
-
-	UINT32					ulRc = cOCT6100_ERR_OK;
-	INT					SemId;
-	FILE *					hSemFile = NULL;
-	BOOL					fFileCreated = FALSE;
-	key_t					Key;
-	int					iSemCnt = 1;
-	tPSEM_INF				pSemInf = NULL;
-	union semun 				SemArg;
-	tSEM_FILE_INF				SemFileInf;
-	struct stat				FileStat;
-	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
-
-	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pCreate->pProcessContext;
-
-	if ( ( f_pCreate == NULL ) || ( f_pCreate->pszSerialObjName == NULL )  )
-		return cOCT6100_CREATE_SERIAL_FAILED_0;
-
-	/* Alloc a sem inf structure */
-	pSemInf = (tPSEM_INF)malloc( sizeof(tSEM_INF) );
-
-	/* Check if malloc failed!!! */
-	if ( pSemInf == NULL )
-		return cOCT6100_CREATE_SERIAL_FAILED_0; /* No memory. */
-
-	snprintf( pSemInf->szFileName, PATH_MAX, "/tmp/%s", f_pCreate->pszSerialObjName );
-
-	/* File exist? */
-	if( stat( pSemInf->szFileName, &FileStat ) )
-	{
-		/* Not main process, this file must exist */
-		if ( pContext->fMainProcess == FALSE )
-		{
-			/* The file does not exist, and we are not the main process. */
-			ulRc = cOCT6100_CREATE_SERIAL_FAILED_1;
-		}
-		else
-		{
-			/* create the file */
-			hSemFile = fopen( pSemInf->szFileName, "w+b" );
-			if( !hSemFile )
-			{
-				ulRc = cOCT6100_CREATE_SERIAL_FAILED_2;
-			}
-			else
-			{
-				fFileCreated = TRUE;
-				memset( &SemFileInf, 0x0, sizeof(SemFileInf) );
-			}
-		}
-		SemFileInf.ulMainProcessId = getpid();
-	}
-	else
-	{
-		/* The semaphore exists.  Open it. */
-		hSemFile = fopen( pSemInf->szFileName, "r+b" );
-		/* Retrieve info from file */
-		if ( sizeof(SemFileInf) != fread( &SemFileInf, 1, sizeof(SemFileInf), hSemFile ) )
-		{
-			ulRc = cOCT6100_CREATE_SERIAL_FAILED_2;
-		}
-		/* rewind file */
-		rewind( hSemFile );
-	}
-
-	if ( cOCT6100_ERR_OK == ulRc )
-	{
-		/* This will create a key with upper bits set to 'K' ( 0x4b ) */
-		Key = ftok( pSemInf->szFileName, 'K' );
-
-		if ( -1 == Key )
-		{
-			ulRc = cOCT6100_CREATE_SERIAL_FAILED_2;
-		}
-	}
-
-	if ( cOCT6100_ERR_OK == ulRc )
-	{
-		/* Get the semaphore or create it */
-		SemId = semget( Key, iSemCnt, IPC_CREAT | 0666 /* | IPC_EXCL */ );
-
-		if ( -1 == SemId )
-		{
-			ulRc = cOCT6100_CREATE_SERIAL_FAILED_3;
-		}
-	}
-
-	if ( cOCT6100_ERR_OK == ulRc )
-	{
-		SemArg.val = 1;
-		iSemCnt = 0;
-		if ( 0 == semctl( SemId, iSemCnt, SETVAL, SemArg ))
-		{
-			/* Store handle and id */
-			pSemInf->SemId = SemId;
-
-			/* increment usage count */
-			SemFileInf.ulUsageCount++;
-			/* write file */
-			if ( sizeof(SemFileInf) != fwrite( &SemFileInf, 1, sizeof(SemFileInf), hSemFile ) )
-			{
-				ulRc = cOCT6100_CREATE_SERIAL_FAILED_4;
-			}
-			else
-			{
-				/* commit write */
-				fflush( hSemFile );
-				fclose( hSemFile );
-				signal( SIGALRM, SigArlmHandler );
-				
-				/* Keep pointer to semaphore information. */
-				f_pCreate->ulSerialObjHndl = (UINT32)pSemInf;	
-			}
-		}
-		else
-		{
-			ulRc = cOCT6100_CREATE_SERIAL_FAILED_4;
-		}
-	}
-	
-	/* Any errors ? */
-	if ( cOCT6100_ERR_OK != ulRc )
-	{
-		if ( -1 != SemId )
-		{
-			/* remove semaphore */
-			semctl( SemId, 0, IPC_RMID, SemArg );    
-		}
-		if ( NULL != hSemFile )
-		{
-			fclose( hSemFile );
-		}
-
-		if ( pSemInf )
-		{
-			if ( fFileCreated )
-			{
-				unlink( pSemInf->szFileName );
-			}
-
-			free( pSemInf );
-		}
-	}
-
-	return ulRc;
-#else
-
-	return cOCT6100_ERR_OK;
-#endif
-}
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDestroySerializeObject
-
-Description:	Destroys the indicated serialization object.
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN f_pDestroy			Pointer to structure containing the handle of the
-				serialization object.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDestroySerializeObject(
-
-			IN tPOCT6100_DESTROY_SERIALIZE_OBJECT		f_pDestroy )
-{	
-
-#if !defined(WAN_KERNEL)
-	UINT32		ulRc = cOCT6100_ERR_OK;
-	tPSEM_INF	pSemInf;
-
-	if ( ( f_pDestroy == NULL ) || ( f_pDestroy->ulSerialObjHndl == 0x0 ) )
-		return cOCT6100_DESTROY_SERIAL_FAILED_0;
-
-	pSemInf = (tPSEM_INF)(f_pDestroy->ulSerialObjHndl);
-
-	/* Check mutex handle */
-	if ( -1 != pSemInf->SemId )
-	{
-		FILE *			hSemFile = NULL;
-		tSEM_FILE_INF	SemFileInf;
-
-		/* Default is failure */
-		ulRc = cOCT6100_DESTROY_SERIAL_FAILED_0;
-
-		hSemFile = fopen( pSemInf->szFileName, "rb" );
-
-		if ( hSemFile )
-		{
-			/* read sem file inf */
-			if ( sizeof(SemFileInf) == fread( &SemFileInf, 1, sizeof(SemFileInf), hSemFile ) )
-			{
-				/* remove a link on that sem */
-				if ( SemFileInf.ulUsageCount > 0 )
-				{
-					SemFileInf.ulUsageCount--;
-				}
-
-				/* Last reference gone ? */
-				if( !SemFileInf.ulUsageCount )
-				{
-					union semun 	SemArg;
-
-					/* Close semaphore, this must be called when no one is waiting on sem */
-					if( semctl( pSemInf->SemId, 0, IPC_RMID, SemArg ) != -1 )
-					{
-						/* Close file */
-						fclose( hSemFile );
-						/* delete file */
-						unlink( pSemInf->szFileName );
-						/* release memory */
-						free( pSemInf );
-
-						/* return done */
-						f_pDestroy->ulSerialObjHndl = 0x0;
-						ulRc = cOCT6100_ERR_OK;
-					}
-				}
-				else
-				{
-					/* commit change */
-					rewind( hSemFile );
-					fwrite( &SemFileInf, 1, sizeof(SemFileInf), hSemFile );
-					/* commit write */
-					fflush( hSemFile );
-					fclose( hSemFile );
-					free( pSemInf );
-					/* If not in the main process, nothing much to do ... */
-					f_pDestroy->ulSerialObjHndl = 0x0;
-					ulRc = cOCT6100_ERR_OK;
-				}
-			}
-		}
-	}
-
-	return ulRc;
-#else
-
-	return cOCT6100_ERR_OK;
-#endif
-}
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserSeizeSerializeObject
-
-Description:	Seizes the indicated serialization object.
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN f_pSeize			Pointer to structure containing the handle of the
-				serialization object.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserSeizeSerializeObject(
-
-			IN tPOCT6100_SEIZE_SERIALIZE_OBJECT			f_pSeize )
-{
-
-#if !defined(WAN_KERNEL)
-	UINT32			ulRc = cOCT6100_ERR_OK;
-	tPSEM_INF		pSemInf;
-
-	if( f_pSeize == NULL )
-		return cOCT6100_SEIZE_SERIAL_FAILED_0;
-
-	if ( f_pSeize->ulSerialObjHndl == 0 )
-		return cOCT6100_SEIZE_SERIAL_FAILED_0;
-
-	pSemInf = (tPSEM_INF)f_pSeize->ulSerialObjHndl;
-
-	/* Check mutex handle */
-	if ( pSemInf )
-	{
-		INT			iRes = 0;
-		struct itimerval	TimerSetting;
-
-		ulRc = cOCT6100_SEIZE_SERIAL_FAILED_1;
-		
-		/* Check if must create a timer. */
-		if( cOCT6100_WAIT_INFINITELY != f_pSeize->ulTryTimeMs )
-		{
-			/* Set the alarm */
-			TimerSetting.it_value.tv_sec = ( f_pSeize->ulTryTimeMs / 1000 );
-			TimerSetting.it_value.tv_usec = ( f_pSeize->ulTryTimeMs % 1000 ) * 1000;
-			/* No repeat please! */
-			TimerSetting.it_interval.tv_sec = 0;
-			TimerSetting.it_interval.tv_usec = 0;
-
-			iRes = setitimer( ITIMER_REAL, &TimerSetting, NULL );
-		}
-		
-		if( iRes != -1 )
-		{
-			/* Timer is armed! */
-			struct sembuf LockSEM[1] = { { 0, -1, SEM_UNDO } };
-
-			iRes = semop( pSemInf->SemId, LockSEM, 1 );
-
-			if( iRes == -1 )
-			{
-				switch( errno )
-				{
-					case EINTR:
-						ulRc = cOCT6100_SEIZE_SERIAL_FAILED_2;
-						break;
-					default:
-						break;
-				}
-			}
-			else
-			{
-				ulRc = cOCT6100_ERR_OK;
-			}
-			
-			if( cOCT6100_WAIT_INFINITELY != f_pSeize->ulTryTimeMs )
-			{
-				/* Disarm timer */
-				TimerSetting.it_value.tv_sec = 0;
-				TimerSetting.it_value.tv_usec = 0;
-
-				setitimer( ITIMER_REAL, &TimerSetting, NULL );
-			}
-		}
-	}
-	return( ulRc );
-#else
-	return cOCT6100_ERR_OK;
-
-#endif
-
-}
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserReleaseSerializeObject
-
-Description:	Releases the indicated serialization object.
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN f_pRelease			Pointer to structure containing the handle of the
-				serialization object.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserReleaseSerializeObject(
-
-			IN tPOCT6100_RELEASE_SERIALIZE_OBJECT		f_pRelease )
-{
-
-#if !defined(WAN_KERNEL)
-	UINT32		ulRc = cOCT6100_ERR_OK;
-	tPSEM_INF	pSemInf;
-
-	if( f_pRelease == NULL )
-		return cOCT6100_RELEASE_SERIAL_FAILED_0;
-
-	if ( f_pRelease->ulSerialObjHndl == 0 )
-		return cOCT6100_RELEASE_SERIAL_FAILED_0;
-
-	pSemInf = (tPSEM_INF)f_pRelease->ulSerialObjHndl;
-
-	/* Check mutex handle */
-	if ( pSemInf )
-	{
-		struct sembuf UnlockSEM[1] = { { 0, 1, SEM_UNDO } };
-		int iRes;
-		
-		ulRc = cOCT6100_ERR_OK;
-
-		iRes = semop( pSemInf->SemId, UnlockSEM, 1 );
-
-		if( iRes == -1 )
-		{
-			ulRc = cOCT6100_RELEASE_SERIAL_FAILED_1;
-		}
-	}
-
-	return( ulRc );
-#else
-
-	return cOCT6100_ERR_OK;
-#endif
-
-}
-
-
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverWriteApi
-
-Description:    Performs a write access to the chip. This function is
-		accessible only from the API code entity (i.e. not from the
-		APIMI code entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN f_pWriteParams		Pointer to structure containing the Params to the
-				write function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverWriteApi(
-			IN	tPOCT6100_WRITE_PARAMS	f_pWriteParams )
-{
-	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
-	unsigned int				err;
-
-	/*  The pProcessContext is there in case the user needs context information
-	in order to perform the access. Note that if it is used, the memory pointed 
-	by this pointer	must be allocated by the user beforehand. */
-	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pWriteParams->pProcessContext;
-
-	/* Check if driver context exists. In this implementation, the context */
-	/* contains driver and semaphore information to perform I/O. */
-	if ( pContext == NULL )
-		return cOCT6100_DRIVER_WRITE_FAILED_0;
-
-	err = wanec_req_write(
-				pContext->ec_dev,
-				f_pWriteParams->ulWriteAddress,
-				f_pWriteParams->usWriteData);
-	if (err){
-		return cOCT6100_DRIVER_WRITE_FAILED_1;
-	}
-	return cOCT6100_ERR_OK;
-}
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverWriteOs
-
-Description:    Performs a write access to the chip. This function is
-		accessible only from the APIMI code entity (i.e. not from the
-		API code entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN f_pWriteParams		Pointer to structure containing the Params to the
-				write function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverWriteOs(
-			IN	tPOCT6100_WRITE_PARAMS	f_pWriteParams )
-{
-
-	/* We assume that the interrupts are blocked during the 
-	Oct6100UserDriverWriteApi calls and that the Oct6100UserDriverWriteApi 
-	function is accessible in an interrupt context */
-
-	return Oct6100UserDriverWriteApi( f_pWriteParams );
-}
-
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverWriteSmearApi
-
-Description:    Performs a series of write accesses to the chip. The same data
-		word is written to a series of addresses. The writes begin at
-		the start address, and the address is incremented by the
-		indicated amount for each subsequent write. This function is
-		accessible only from the API code entity (i.e. not from the
-		APIMI code entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN f_pSmearParams		Pointer to structure containing the Params to the
-				write function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverWriteSmearApi(
-			IN	tPOCT6100_WRITE_SMEAR_PARAMS	f_pSmearParams )
-{
-
-	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
-	unsigned int				err;
-
-	/*  The pProcessContext is there in case the user needs context information
-	in order to perform the access. Note that if it is used, the memory pointed 
-	by this pointer	must be allocated by the user beforehand. */
-	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pSmearParams->pProcessContext;
-
-	/* Check if driver context exists. In this implementation, the context */
-	/* contains driver and semaphore information to perform I/O. */
-	if ( pContext == NULL )
-		return cOCT6100_DRIVER_WSMEAR_FAILED_0;
-
-	err = wanec_req_write_smear(
-				pContext->ec_dev,
-				f_pSmearParams->ulWriteAddress,
-				f_pSmearParams->usWriteData,
-				f_pSmearParams->ulWriteLength);
-	if (err){
-		return cOCT6100_DRIVER_WSMEAR_FAILED_1;
-	}
-
-	return cOCT6100_ERR_OK;
-}
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverWriteSmearOs
-
-Description:    Performs a series of write accesses to the chip. The same data
-		word is written to a series of addresses. The writes begin at
-		the start address, and the address is incremented by the
-		indicated amount for each subsequent write. This function is
-		accessible only from the APIMI code entity (i.e. not from the
-		API code entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN f_pSmearParams		Pointer to structure containing the Params to the
-				write function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverWriteSmearOs(
-
-			IN	tPOCT6100_WRITE_SMEAR_PARAMS			f_pSmearParams )
-{
-	/* We assume that the interrupts are blocked during the 
-	Oct6100UserDriverWriteApi calls and that the Oct6100UserDriverWriteSmearApi 
-	function is accessible in an interrupt context */
-
-	return Oct6100UserDriverWriteSmearApi( f_pSmearParams );
-}
-
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverWriteBurstApi
-
-Description:    Performs a series of write accesses to the chip. An array of
-		data words is written to a series of consecutive addresses.
-		The writes begin at the start address with element 0 of the
-		provided array as the data word. The address is incremented by
-		two for each subsequent write. This function is accessible only
-		from the API code entity (i.e. not from the APIMI code entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN f_pSmearParams		Pointer to structure containing the Params to the
-				write function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverWriteBurstApi(
-			IN	tPOCT6100_WRITE_BURST_PARAMS	f_pBurstParams )
-{
-
-	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
-	unsigned int	i, err;
-	unsigned short	*data;
-
-	/*  The pProcessContext is there in case the user needs context information
-	in order to perform the access. Note that if it is used, the memory pointed 
-	by this pointer	must be allocated by the user beforehand. */
-	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pBurstParams->pProcessContext;
-
-	/* Check if driver context exists. In this implementation, the context */
-	/* contains driver and semaphore information to perform I/O. */
-	if ( pContext == NULL )
-		return cOCT6100_DRIVER_WBURST_FAILED_0;
-
-	/* In this case, the message is allocated dynamically since we do not know */
-	/* in advance the size of the array to be passed down to the driver. */
-#if defined(WAN_KERNEL)
-	data = wan_malloc(f_pBurstParams->ulWriteLength * sizeof(unsigned short));
-#else
-	data = malloc(f_pBurstParams->ulWriteLength * sizeof(unsigned short));
-#endif
-	if (data == NULL){
-		return cOCT6100_DRIVER_WBURST_FAILED_1;
-	}
-
-	/* Copy payload to be transported to driver. */
-	for(i = 0; i < f_pBurstParams->ulWriteLength; i++ )
-		data[i] = f_pBurstParams->pusWriteData[i];
-
-	err = wanec_req_write_burst(
-				pContext->ec_dev,
-				f_pBurstParams->ulWriteAddress,
-				data,
-				f_pBurstParams->ulWriteLength);
-	/* Cleanup allocated memory. */
-#if defined(WAN_KERNEL)
-	wan_free( data );
-#else
-	free( data );
-#endif
-
-	if (err){
-		return cOCT6100_DRIVER_WBURST_FAILED_2;
-	}
-
-	return cOCT6100_ERR_OK;
-}
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverWriteBurstOs
-
-Description:    Performs a series of write accesses to the chip. An array of
-		data words is written to a series of consecutive addresses.
-		The writes begin at the start address with element 0 of the
-		provided array as the data word. The address is incremented by
-		two for each subsequent write. This function is accessible only
-		from the API code entity (i.e. not from the APIMI code entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN f_pBurstParams		Pointer to structure containing the Params to the
-				write function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverWriteBurstOs(
-			IN	tPOCT6100_WRITE_BURST_PARAMS	f_pBurstParams )
-{
-
-	/* We assume that the interrupts are blocked during the 
-	Oct6100UserDriverWriteApi calls and that the Oct6100UserDriverWriteBurstApi 
-	function is accessible in an interrupt context */
-	
-	return Oct6100UserDriverWriteBurstApi( f_pBurstParams );
-}
-
-
-
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverReadApi
-
-Description:    Performs a read access to the chip. This function is accessible
-		only from the API code entity (i.e. not from the APIMI code
-		entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN OUT f_pReadParams		Pointer to structure containing the Params to the
-				read function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverReadApi(
-			IN OUT	tPOCT6100_READ_PARAMS	f_pReadParams )
-{
-	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
-	unsigned int				err;
-
-	/*  The pProcessContext is there in case the user needs context information
-	in order to perform the access. Note that if it is used, the memory pointed 
-	by this pointer	must be allocated by the user beforehand. */
-	
-	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pReadParams->pProcessContext;
-
-	/* Check if driver context exists. In this implementation, the context */
-	/* contains driver and semaphore information to perform I/O. */
-	if ( pContext == NULL )
-		return cOCT6100_DRIVER_READ_FAILED_0;
-
-	err = wanec_req_read(
-				pContext->ec_dev,
-				f_pReadParams->ulReadAddress,
-				f_pReadParams->pusReadData);
-	if (err){
-		return cOCT6100_DRIVER_READ_FAILED_1;
-	}
-
-	return cOCT6100_ERR_OK;
-}
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverReadOs
-
-Description:    Performs a read access to the chip. This function is accessible
-		only from the APIMI code entity (i.e. not from the API code
-		entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN OUT f_pReadParams		Pointer to structure containing the Params to the
-				read function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverReadOs(
-			IN OUT	tPOCT6100_READ_PARAMS	f_pReadParams )
-{
-
-	/* We assume that the interrupts are blocked during the 
-	Oct6100UserDriverReadApi calls and that the Oct6100UserDriverReadApi 
-	function is accessible in an interrupt context */
-	return Oct6100UserDriverReadApi( f_pReadParams );
-}
-
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverReadBurstApi
-
-Description:    Performs a burst of read accesses to the chip. The first read
-		is performed at the start address, and the address is
-		incremented by two for each subsequent read. The data is
-		retunred in an array provided by the user. This function is
-		accessible only from the API code entity (i.e. not from the
-		APIMI code entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN OUT f_pBurstParams		Pointer to structure containing the Params to the
-				read function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverReadBurstApi(
-			IN OUT	tPOCT6100_READ_BURST_PARAMS	f_pBurstParams )
-{
-	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
-	unsigned int	i, err;
-	unsigned short	*data;
-
-	/*  The pProcessContext is there in case the user needs context information
-	in order to perform the access. Note that if it is used, the memory pointed 
-	by this pointer	must be allocated by the user beforehand. */
-	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pBurstParams->pProcessContext;
-
-	/* Check if driver context exists. In this implementation, the context */
-	/* contains driver and semaphore information to perform I/O. */
-	if ( pContext == NULL )
-		return cOCT6100_DRIVER_RBURST_FAILED_0;
-
-	/* In this case, the message is allocated dynamically since we do not know */
-	/* in advance the size of the array to be passed down to the driver. */
-#if defined(WAN_KERNEL)
-	data = (unsigned short*)wan_malloc(f_pBurstParams->ulReadLength * sizeof(unsigned short));
-#else
-	data = (unsigned short*)malloc(f_pBurstParams->ulReadLength * sizeof(unsigned short));
-#endif
-	if (data == NULL){
-		return cOCT6100_DRIVER_RBURST_FAILED_1;
-	}
-	err = wanec_req_read_burst(
-				pContext->ec_dev,
-				f_pBurstParams->ulReadAddress,
-				data,
-				f_pBurstParams->ulReadLength);	
-
-	/* Copy result to the user. */
-	if (!err){
-		for(i = 0; i < f_pBurstParams->ulReadLength; i++){
-			f_pBurstParams->pusReadData[i] = data[i];
-		}
-	}
-	
-	/* Cleanup allocated memory. */
-#if defined(WAN_KERNEL)
-	wan_free(data);
-#else
-	free(data);
-#endif
-
-	if (err){
-		return cOCT6100_DRIVER_RBURST_FAILED_2;
-	}
-
-	return cOCT6100_ERR_OK;
-}
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverReadBurstOs
-
-Description:    Performs a burst of read accesses to the chip. The first read
-		is performed at the start address, and the address is
-		incremented by two for each subsequent read. The data is
-		retunred in an array provided by the user. This function is
-		accessible only from the APIMI code entity (i.e. not from the
-		API code entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN OUT f_pBurstParams		Pointer to structure containing the Params to the
-				read function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverReadBurstOs(
-			IN OUT	tPOCT6100_READ_BURST_PARAMS	f_pBurstParams )
-{
-	/* We assume that the interrupts are blocked during the 
-	Oct6100UserDriverReadApi calls and that the  
-	Oct6100UserDriverReadBurstApi function is accessible 
-	in an interrupt context */
-	return Oct6100UserDriverReadBurstApi(f_pBurstParams);
-}
-
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+File: oct6100_user.c
+
+	Copyright (c) 2001 Octasic Inc. All rights reserved.
+    
+Description: 
+
+	This file contains the functions provided by the user.
+
+This source code is Octasic Confidential. Use of and access to this code
+is covered by the Octasic Device Enabling Software License Agreement. 
+Acknowledgement of the Octasic Device Enabling Software License was 
+required for access to this code. A copy was also provided with the release.
+
+
+$Octasic_Release: OCT612xAPI-01.00-PR37 $
+
+$Octasic_Revision: 25 $
+
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+
+
+/*****************************  INCLUDE FILES  *******************************/
+
+
+/* System specific includes */
+#if defined(WAN_EC_USER)
+# include <unistd.h>
+# include <stdio.h>
+# include <stdlib.h>
+# include <time.h>
+# include <sys/fcntl.h>
+# include <sys/time.h>
+# include <sys/stat.h>
+# include <sys/types.h>
+# include <sys/ipc.h>
+# include <sys/sem.h>
+# include <sys/queue.h>
+# include <getopt.h>
+# include <limits.h>
+# include <errno.h>
+# include <memory.h>
+# include <signal.h>
+# include <semaphore.h>
+# include <sys/ioctl.h>
+# if defined(__LINUX__)
+#  include <linux/wanpipe_defines.h>
+#  include <linux/wanpipe_cfg.h>
+# elif defined(__FreeBSD__) || defined(__OpenBSD__)
+#  include <wanpipe_defines.h>
+#  include <wanpipe_cfg.h>
+# endif
+# include "oct6100api/oct6100_apiud.h"
+# include "oct6100api/oct6100_errors.h"
+# include "oct6100api/oct6100_api.h"
+# include "oct6100_version.h"
+# include "wanec_iface.h"
+#else
+# if defined(__LINUX__)
+#  include <linux/wanpipe_includes.h>
+#  include <linux/wanpipe_defines.h>
+#  include <linux/wanpipe_debug.h>
+#  include <linux/wanpipe_common.h>
+#  include <linux/wanpipe_cfg.h>
+#  include <linux/if_wanpipe.h>
+#  include <linux/wanpipe.h>
+# else
+#  include <wanpipe_includes.h>
+#  include <wanpipe_defines.h>
+#  include <wanpipe_debug.h>
+#  include <wanpipe_common.h>
+#  include <wanpipe.h>
+#  include <wanpipe_cfg.h>
+# endif
+
+#include "oct6100api/oct6100_apiud.h"
+#include "oct6100api/oct6100_errors.h"
+
+#include "oct6100api/oct6100_api.h"
+#include "oct6100_version.h"
+
+# include "wanec_iface.h"
+#endif
+
+extern u_int32_t wanec_req_write(void*, u_int32_t write_addr, u_int16_t write_data);
+extern u_int32_t wanec_req_write_smear(void*, u_int32_t addr, u_int16_t data, u_int32_t len);
+extern u_int32_t wanec_req_write_burst(void*, u_int32_t addr, u_int16_t *data, u_int32_t len);
+extern u_int32_t wanec_req_read(void*, u_int32_t addr, u_int16_t *data);
+extern u_int32_t wanec_req_read_burst(void*, u_int32_t addr, u_int16_t *data, u_int32_t len);
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserGetTime
+
+Description:	Returns the system time in us.
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN OUT f_pTime		Pointer to structure in which the time is returned.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+
+UINT32 Oct6100UserGetTime(
+
+			IN OUT tPOCT6100_GET_TIME	f_pTime )
+{
+	clock_t		ulClockTicks;
+	struct timeval	TimeVal;
+	static UINT32	ulWallTimeUsHigh = 0;
+	static UINT32	ulWallTimeUsLow = 0;
+
+	if( !f_pTime )
+		return cOCT6100_GET_TIME_FAILED_0;
+
+#if !defined(__WINDOWS__)
+	/* Retrieve clock tick */
+#if defined(WAN_KERNEL)
+	wan_getcurrenttime( &TimeVal.tv_sec, &TimeVal.tv_usec );
+#else
+	gettimeofday( &TimeVal, NULL );
+#endif
+	/* ulClockTicks = ( TimeVal.tv_sec * 1000000 ) + ( TimeVal.tv_usec ); */
+	/* Create a value im ms (as clock does) */
+	ulClockTicks = ( TimeVal.tv_sec * 1000 ) + ( TimeVal.tv_usec /1000 );
+#else
+	ulClockTicks = wpabs_get_systemticks();
+#endif
+
+	/* move to micro sec */
+	ulClockTicks *= 1000;
+
+	/* Did it wrap ? */
+	if ( (UINT32)ulClockTicks < ulWallTimeUsLow )
+	{
+		/* Yes, so increment MSB */
+		ulWallTimeUsHigh++;
+	}
+
+	f_pTime->aulWallTimeUs[ 0 ] = ulClockTicks;
+	f_pTime->aulWallTimeUs[ 1 ] = ulWallTimeUsHigh;
+	ulWallTimeUsLow = f_pTime->aulWallTimeUs[ 0 ];
+
+	return cOCT6100_ERR_OK;
+}
+
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserMemSet
+
+Description:	Sets f_ulLength bytes pointed to by f_pAddress to f_ulPattern.
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserMemSet(
+			IN	PVOID	f_pAddress,
+			IN	UINT32	f_ulPattern,
+			IN	UINT32	f_ulLength )
+{
+
+	memset( f_pAddress, f_ulPattern, f_ulLength );
+
+	return cOCT6100_ERR_OK;
+}
+
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserMemCopy
+
+Description:	Copy f_ulLength bytes from f_pSource to f_pDestination.
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserMemCopy(
+			IN	PVOID	f_pDestination,
+			IN	PVOID	f_pSource,
+			IN	UINT32	f_ulLength )
+{
+
+	memcpy( f_pDestination, f_pSource, f_ulLength );
+
+	return cOCT6100_ERR_OK;
+}
+
+
+#if !defined(WAN_KERNEL)
+static void SigArlmHandler()
+{
+}
+#endif
+
+#if defined(__GNU_LIBRARY__) && !defined(_SEM_SEMUN_UNDEFINED) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(WAN_KERNEL)
+/* union semun is defined by including <sys/sem.h> */
+#else
+/* according to X/OPEN we have to define it ourselves */
+union semun {
+	int val;                  /* value for SETVAL */
+	struct semid_ds *buf;     /* buffer for IPC_STAT, IPC_SET */
+	unsigned short *array;    /* array for GETALL, SETALL */
+                              /* Linux specific part: */
+	struct seminfo *__buf;    /* buffer for IPC_INFO */
+};
+#endif
+
+typedef struct _SEM_FILE_INF_
+{
+	UINT32		ulMainProcessId;
+	UINT32		ulUsageCount;
+
+} tSEM_FILE_INF, *tPSEM_FILE_INF;
+
+typedef struct _SEM_INF_
+{
+	INT			SemId;
+	CHAR		szFileName[PATH_MAX];
+
+} tSEM_INF, *tPSEM_INF;
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserCreateSerializeObject
+
+Description:	Creates a serialization object. The serialization object is
+				seized via the Oct6100UserSeizeSerializeObject function.
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN OUT f_pCreate		Pointer to structure in which the serialization object's
+				handle is returned.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserCreateSerializeObject(
+
+		IN OUT tPOCT6100_CREATE_SERIALIZE_OBJECT	f_pCreate )
+{
+
+#if !defined(WAN_KERNEL)
+
+	UINT32					ulRc = cOCT6100_ERR_OK;
+	INT					SemId;
+	FILE *					hSemFile = NULL;
+	BOOL					fFileCreated = FALSE;
+	key_t					Key;
+	int					iSemCnt = 1;
+	tPSEM_INF				pSemInf = NULL;
+	union semun 				SemArg;
+	tSEM_FILE_INF				SemFileInf;
+	struct stat				FileStat;
+	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
+
+	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pCreate->pProcessContext;
+
+	if ( ( f_pCreate == NULL ) || ( f_pCreate->pszSerialObjName == NULL )  )
+		return cOCT6100_CREATE_SERIAL_FAILED_0;
+
+	/* Alloc a sem inf structure */
+	pSemInf = (tPSEM_INF)malloc( sizeof(tSEM_INF) );
+
+	/* Check if malloc failed!!! */
+	if ( pSemInf == NULL )
+		return cOCT6100_CREATE_SERIAL_FAILED_0; /* No memory. */
+
+	snprintf( pSemInf->szFileName, PATH_MAX, "/tmp/%s", f_pCreate->pszSerialObjName );
+
+	/* File exist? */
+	if( stat( pSemInf->szFileName, &FileStat ) )
+	{
+		/* Not main process, this file must exist */
+		if ( pContext->fMainProcess == FALSE )
+		{
+			/* The file does not exist, and we are not the main process. */
+			ulRc = cOCT6100_CREATE_SERIAL_FAILED_1;
+		}
+		else
+		{
+			/* create the file */
+			hSemFile = fopen( pSemInf->szFileName, "w+b" );
+			if( !hSemFile )
+			{
+				ulRc = cOCT6100_CREATE_SERIAL_FAILED_2;
+			}
+			else
+			{
+				fFileCreated = TRUE;
+				memset( &SemFileInf, 0x0, sizeof(SemFileInf) );
+			}
+		}
+		SemFileInf.ulMainProcessId = getpid();
+	}
+	else
+	{
+		/* The semaphore exists.  Open it. */
+		hSemFile = fopen( pSemInf->szFileName, "r+b" );
+		/* Retrieve info from file */
+		if ( sizeof(SemFileInf) != fread( &SemFileInf, 1, sizeof(SemFileInf), hSemFile ) )
+		{
+			ulRc = cOCT6100_CREATE_SERIAL_FAILED_2;
+		}
+		/* rewind file */
+		rewind( hSemFile );
+	}
+
+	if ( cOCT6100_ERR_OK == ulRc )
+	{
+		/* This will create a key with upper bits set to 'K' ( 0x4b ) */
+		Key = ftok( pSemInf->szFileName, 'K' );
+
+		if ( -1 == Key )
+		{
+			ulRc = cOCT6100_CREATE_SERIAL_FAILED_2;
+		}
+	}
+
+	if ( cOCT6100_ERR_OK == ulRc )
+	{
+		/* Get the semaphore or create it */
+		SemId = semget( Key, iSemCnt, IPC_CREAT | 0666 /* | IPC_EXCL */ );
+
+		if ( -1 == SemId )
+		{
+			ulRc = cOCT6100_CREATE_SERIAL_FAILED_3;
+		}
+	}
+
+	if ( cOCT6100_ERR_OK == ulRc )
+	{
+		SemArg.val = 1;
+		iSemCnt = 0;
+		if ( 0 == semctl( SemId, iSemCnt, SETVAL, SemArg ))
+		{
+			/* Store handle and id */
+			pSemInf->SemId = SemId;
+
+			/* increment usage count */
+			SemFileInf.ulUsageCount++;
+			/* write file */
+			if ( sizeof(SemFileInf) != fwrite( &SemFileInf, 1, sizeof(SemFileInf), hSemFile ) )
+			{
+				ulRc = cOCT6100_CREATE_SERIAL_FAILED_4;
+			}
+			else
+			{
+				/* commit write */
+				fflush( hSemFile );
+				fclose( hSemFile );
+				signal( SIGALRM, SigArlmHandler );
+				
+				/* Keep pointer to semaphore information. */
+				f_pCreate->ulSerialObjHndl = (UINT32)pSemInf;	
+			}
+		}
+		else
+		{
+			ulRc = cOCT6100_CREATE_SERIAL_FAILED_4;
+		}
+	}
+	
+	/* Any errors ? */
+	if ( cOCT6100_ERR_OK != ulRc )
+	{
+		if ( -1 != SemId )
+		{
+			/* remove semaphore */
+			semctl( SemId, 0, IPC_RMID, SemArg );    
+		}
+		if ( NULL != hSemFile )
+		{
+			fclose( hSemFile );
+		}
+
+		if ( pSemInf )
+		{
+			if ( fFileCreated )
+			{
+				unlink( pSemInf->szFileName );
+			}
+
+			free( pSemInf );
+		}
+	}
+
+	return ulRc;
+#else
+
+	return cOCT6100_ERR_OK;
+#endif
+}
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDestroySerializeObject
+
+Description:	Destroys the indicated serialization object.
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN f_pDestroy			Pointer to structure containing the handle of the
+				serialization object.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDestroySerializeObject(
+
+			IN tPOCT6100_DESTROY_SERIALIZE_OBJECT		f_pDestroy )
+{	
+
+#if !defined(WAN_KERNEL)
+	UINT32		ulRc = cOCT6100_ERR_OK;
+	tPSEM_INF	pSemInf;
+
+	if ( ( f_pDestroy == NULL ) || ( f_pDestroy->ulSerialObjHndl == 0x0 ) )
+		return cOCT6100_DESTROY_SERIAL_FAILED_0;
+
+	pSemInf = (tPSEM_INF)(f_pDestroy->ulSerialObjHndl);
+
+	/* Check mutex handle */
+	if ( -1 != pSemInf->SemId )
+	{
+		FILE *			hSemFile = NULL;
+		tSEM_FILE_INF	SemFileInf;
+
+		/* Default is failure */
+		ulRc = cOCT6100_DESTROY_SERIAL_FAILED_0;
+
+		hSemFile = fopen( pSemInf->szFileName, "rb" );
+
+		if ( hSemFile )
+		{
+			/* read sem file inf */
+			if ( sizeof(SemFileInf) == fread( &SemFileInf, 1, sizeof(SemFileInf), hSemFile ) )
+			{
+				/* remove a link on that sem */
+				if ( SemFileInf.ulUsageCount > 0 )
+				{
+					SemFileInf.ulUsageCount--;
+				}
+
+				/* Last reference gone ? */
+				if( !SemFileInf.ulUsageCount )
+				{
+					union semun 	SemArg;
+
+					/* Close semaphore, this must be called when no one is waiting on sem */
+					if( semctl( pSemInf->SemId, 0, IPC_RMID, SemArg ) != -1 )
+					{
+						/* Close file */
+						fclose( hSemFile );
+						/* delete file */
+						unlink( pSemInf->szFileName );
+						/* release memory */
+						free( pSemInf );
+
+						/* return done */
+						f_pDestroy->ulSerialObjHndl = 0x0;
+						ulRc = cOCT6100_ERR_OK;
+					}
+				}
+				else
+				{
+					/* commit change */
+					rewind( hSemFile );
+					fwrite( &SemFileInf, 1, sizeof(SemFileInf), hSemFile );
+					/* commit write */
+					fflush( hSemFile );
+					fclose( hSemFile );
+					free( pSemInf );
+					/* If not in the main process, nothing much to do ... */
+					f_pDestroy->ulSerialObjHndl = 0x0;
+					ulRc = cOCT6100_ERR_OK;
+				}
+			}
+		}
+	}
+
+	return ulRc;
+#else
+
+	return cOCT6100_ERR_OK;
+#endif
+}
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserSeizeSerializeObject
+
+Description:	Seizes the indicated serialization object.
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN f_pSeize			Pointer to structure containing the handle of the
+				serialization object.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserSeizeSerializeObject(
+
+			IN tPOCT6100_SEIZE_SERIALIZE_OBJECT			f_pSeize )
+{
+
+#if !defined(WAN_KERNEL)
+	UINT32			ulRc = cOCT6100_ERR_OK;
+	tPSEM_INF		pSemInf;
+
+	if( f_pSeize == NULL )
+		return cOCT6100_SEIZE_SERIAL_FAILED_0;
+
+	if ( f_pSeize->ulSerialObjHndl == 0 )
+		return cOCT6100_SEIZE_SERIAL_FAILED_0;
+
+	pSemInf = (tPSEM_INF)f_pSeize->ulSerialObjHndl;
+
+	/* Check mutex handle */
+	if ( pSemInf )
+	{
+		INT			iRes = 0;
+		struct itimerval	TimerSetting;
+
+		ulRc = cOCT6100_SEIZE_SERIAL_FAILED_1;
+		
+		/* Check if must create a timer. */
+		if( cOCT6100_WAIT_INFINITELY != f_pSeize->ulTryTimeMs )
+		{
+			/* Set the alarm */
+			TimerSetting.it_value.tv_sec = ( f_pSeize->ulTryTimeMs / 1000 );
+			TimerSetting.it_value.tv_usec = ( f_pSeize->ulTryTimeMs % 1000 ) * 1000;
+			/* No repeat please! */
+			TimerSetting.it_interval.tv_sec = 0;
+			TimerSetting.it_interval.tv_usec = 0;
+
+			iRes = setitimer( ITIMER_REAL, &TimerSetting, NULL );
+		}
+		
+		if( iRes != -1 )
+		{
+			/* Timer is armed! */
+			struct sembuf LockSEM[1] = { { 0, -1, SEM_UNDO } };
+
+			iRes = semop( pSemInf->SemId, LockSEM, 1 );
+
+			if( iRes == -1 )
+			{
+				switch( errno )
+				{
+					case EINTR:
+						ulRc = cOCT6100_SEIZE_SERIAL_FAILED_2;
+						break;
+					default:
+						break;
+				}
+			}
+			else
+			{
+				ulRc = cOCT6100_ERR_OK;
+			}
+			
+			if( cOCT6100_WAIT_INFINITELY != f_pSeize->ulTryTimeMs )
+			{
+				/* Disarm timer */
+				TimerSetting.it_value.tv_sec = 0;
+				TimerSetting.it_value.tv_usec = 0;
+
+				setitimer( ITIMER_REAL, &TimerSetting, NULL );
+			}
+		}
+	}
+	return( ulRc );
+#else
+	return cOCT6100_ERR_OK;
+
+#endif
+
+}
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserReleaseSerializeObject
+
+Description:	Releases the indicated serialization object.
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN f_pRelease			Pointer to structure containing the handle of the
+				serialization object.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserReleaseSerializeObject(
+
+			IN tPOCT6100_RELEASE_SERIALIZE_OBJECT		f_pRelease )
+{
+
+#if !defined(WAN_KERNEL)
+	UINT32		ulRc = cOCT6100_ERR_OK;
+	tPSEM_INF	pSemInf;
+
+	if( f_pRelease == NULL )
+		return cOCT6100_RELEASE_SERIAL_FAILED_0;
+
+	if ( f_pRelease->ulSerialObjHndl == 0 )
+		return cOCT6100_RELEASE_SERIAL_FAILED_0;
+
+	pSemInf = (tPSEM_INF)f_pRelease->ulSerialObjHndl;
+
+	/* Check mutex handle */
+	if ( pSemInf )
+	{
+		struct sembuf UnlockSEM[1] = { { 0, 1, SEM_UNDO } };
+		int iRes;
+		
+		ulRc = cOCT6100_ERR_OK;
+
+		iRes = semop( pSemInf->SemId, UnlockSEM, 1 );
+
+		if( iRes == -1 )
+		{
+			ulRc = cOCT6100_RELEASE_SERIAL_FAILED_1;
+		}
+	}
+
+	return( ulRc );
+#else
+
+	return cOCT6100_ERR_OK;
+#endif
+
+}
+
+
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverWriteApi
+
+Description:    Performs a write access to the chip. This function is
+		accessible only from the API code entity (i.e. not from the
+		APIMI code entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN f_pWriteParams		Pointer to structure containing the Params to the
+				write function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverWriteApi(
+			IN	tPOCT6100_WRITE_PARAMS	f_pWriteParams )
+{
+	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
+	unsigned int				err;
+
+	/*  The pProcessContext is there in case the user needs context information
+	in order to perform the access. Note that if it is used, the memory pointed 
+	by this pointer	must be allocated by the user beforehand. */
+	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pWriteParams->pProcessContext;
+
+	/* Check if driver context exists. In this implementation, the context */
+	/* contains driver and semaphore information to perform I/O. */
+	if ( pContext == NULL )
+		return cOCT6100_DRIVER_WRITE_FAILED_0;
+
+	err = wanec_req_write(
+				pContext->ec_dev,
+				f_pWriteParams->ulWriteAddress,
+				f_pWriteParams->usWriteData);
+	if (err){
+		return cOCT6100_DRIVER_WRITE_FAILED_1;
+	}
+	return cOCT6100_ERR_OK;
+}
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverWriteOs
+
+Description:    Performs a write access to the chip. This function is
+		accessible only from the APIMI code entity (i.e. not from the
+		API code entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN f_pWriteParams		Pointer to structure containing the Params to the
+				write function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverWriteOs(
+			IN	tPOCT6100_WRITE_PARAMS	f_pWriteParams )
+{
+
+	/* We assume that the interrupts are blocked during the 
+	Oct6100UserDriverWriteApi calls and that the Oct6100UserDriverWriteApi 
+	function is accessible in an interrupt context */
+
+	return Oct6100UserDriverWriteApi( f_pWriteParams );
+}
+
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverWriteSmearApi
+
+Description:    Performs a series of write accesses to the chip. The same data
+		word is written to a series of addresses. The writes begin at
+		the start address, and the address is incremented by the
+		indicated amount for each subsequent write. This function is
+		accessible only from the API code entity (i.e. not from the
+		APIMI code entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN f_pSmearParams		Pointer to structure containing the Params to the
+				write function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverWriteSmearApi(
+			IN	tPOCT6100_WRITE_SMEAR_PARAMS	f_pSmearParams )
+{
+
+	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
+	unsigned int				err;
+
+	/*  The pProcessContext is there in case the user needs context information
+	in order to perform the access. Note that if it is used, the memory pointed 
+	by this pointer	must be allocated by the user beforehand. */
+	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pSmearParams->pProcessContext;
+
+	/* Check if driver context exists. In this implementation, the context */
+	/* contains driver and semaphore information to perform I/O. */
+	if ( pContext == NULL )
+		return cOCT6100_DRIVER_WSMEAR_FAILED_0;
+
+	err = wanec_req_write_smear(
+				pContext->ec_dev,
+				f_pSmearParams->ulWriteAddress,
+				f_pSmearParams->usWriteData,
+				f_pSmearParams->ulWriteLength);
+	if (err){
+		return cOCT6100_DRIVER_WSMEAR_FAILED_1;
+	}
+
+	return cOCT6100_ERR_OK;
+}
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverWriteSmearOs
+
+Description:    Performs a series of write accesses to the chip. The same data
+		word is written to a series of addresses. The writes begin at
+		the start address, and the address is incremented by the
+		indicated amount for each subsequent write. This function is
+		accessible only from the APIMI code entity (i.e. not from the
+		API code entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN f_pSmearParams		Pointer to structure containing the Params to the
+				write function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverWriteSmearOs(
+
+			IN	tPOCT6100_WRITE_SMEAR_PARAMS			f_pSmearParams )
+{
+	/* We assume that the interrupts are blocked during the 
+	Oct6100UserDriverWriteApi calls and that the Oct6100UserDriverWriteSmearApi 
+	function is accessible in an interrupt context */
+
+	return Oct6100UserDriverWriteSmearApi( f_pSmearParams );
+}
+
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverWriteBurstApi
+
+Description:    Performs a series of write accesses to the chip. An array of
+		data words is written to a series of consecutive addresses.
+		The writes begin at the start address with element 0 of the
+		provided array as the data word. The address is incremented by
+		two for each subsequent write. This function is accessible only
+		from the API code entity (i.e. not from the APIMI code entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN f_pSmearParams		Pointer to structure containing the Params to the
+				write function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverWriteBurstApi(
+			IN	tPOCT6100_WRITE_BURST_PARAMS	f_pBurstParams )
+{
+
+	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
+	unsigned int	i, err;
+	unsigned short	*data;
+#if defined(__WINDOWS__)
+	unsigned char tmp_buf[OCT_TMP_MEMORY_SIZE];
+	int rc = SILENT;
+#endif
+
+	/*  The pProcessContext is there in case the user needs context information
+	in order to perform the access. Note that if it is used, the memory pointed 
+	by this pointer	must be allocated by the user beforehand. */
+	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pBurstParams->pProcessContext;
+
+	/* Check if driver context exists. In this implementation, the context */
+	/* contains driver and semaphore information to perform I/O. */
+	if ( pContext == NULL )
+		return cOCT6100_DRIVER_WBURST_FAILED_0;
+
+	/* In this case, the message is allocated dynamically since we do not know */
+	/* in advance the size of the array to be passed down to the driver. */
+#if defined(WAN_KERNEL)
+# if !defined(__WINDOWS__)
+	data = wan_malloc(f_pBurstParams->ulWriteLength * sizeof(unsigned short));
+# else
+	VERIFY_DISPATCH_IRQL(rc);
+	if(rc){
+		//Memory allocation is invalid inside ISR, use a temp buffer.
+		if(f_pBurstParams->ulWriteLength * sizeof(unsigned short) > OCT_TMP_MEMORY_SIZE){
+			DEBUG_EVENT("%s(): Memory requested (%d) bigger than 'temp' (%d) buffer!!\n",
+				__FUNCTION__, f_pBurstParams->ulWriteLength * sizeof(unsigned short), OCT_TMP_MEMORY_SIZE);
+			return cOCT6100_DRIVER_WBURST_FAILED_1;
+		}
+		data = (unsigned short*)tmp_buf;
+	}else{
+		data = wan_malloc(f_pBurstParams->ulWriteLength * sizeof(unsigned short));
+	}
+# endif
+#else
+	data = malloc(f_pBurstParams->ulWriteLength * sizeof(unsigned short));
+#endif
+	if (data == NULL){
+		return cOCT6100_DRIVER_WBURST_FAILED_1;
+	}
+
+	/* Copy payload to be transported to driver. */
+	for(i = 0; i < f_pBurstParams->ulWriteLength; i++ )
+		data[i] = f_pBurstParams->pusWriteData[i];
+
+	err = wanec_req_write_burst(
+				pContext->ec_dev,
+				f_pBurstParams->ulWriteAddress,
+				data,
+				f_pBurstParams->ulWriteLength);
+	/* Cleanup allocated memory. */
+#if defined(WAN_KERNEL)
+# if !defined(__WINDOWS__)
+	wan_free( data );
+# else
+	rc = SILENT;
+	VERIFY_DISPATCH_IRQL(rc);
+	if(rc == 0){
+		wan_free(data);
+	}
+# endif
+#else
+	free( data );
+#endif
+
+	if (err){
+		return cOCT6100_DRIVER_WBURST_FAILED_2;
+	}
+
+	return cOCT6100_ERR_OK;
+}
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverWriteBurstOs
+
+Description:    Performs a series of write accesses to the chip. An array of
+		data words is written to a series of consecutive addresses.
+		The writes begin at the start address with element 0 of the
+		provided array as the data word. The address is incremented by
+		two for each subsequent write. This function is accessible only
+		from the API code entity (i.e. not from the APIMI code entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN f_pBurstParams		Pointer to structure containing the Params to the
+				write function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverWriteBurstOs(
+			IN	tPOCT6100_WRITE_BURST_PARAMS	f_pBurstParams )
+{
+
+	/* We assume that the interrupts are blocked during the 
+	Oct6100UserDriverWriteApi calls and that the Oct6100UserDriverWriteBurstApi 
+	function is accessible in an interrupt context */
+	
+	return Oct6100UserDriverWriteBurstApi( f_pBurstParams );
+}
+
+
+
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverReadApi
+
+Description:    Performs a read access to the chip. This function is accessible
+		only from the API code entity (i.e. not from the APIMI code
+		entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN OUT f_pReadParams		Pointer to structure containing the Params to the
+				read function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverReadApi(
+			IN OUT	tPOCT6100_READ_PARAMS	f_pReadParams )
+{
+	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
+	unsigned int				err;
+
+	/*  The pProcessContext is there in case the user needs context information
+	in order to perform the access. Note that if it is used, the memory pointed 
+	by this pointer	must be allocated by the user beforehand. */
+	
+	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pReadParams->pProcessContext;
+
+	/* Check if driver context exists. In this implementation, the context */
+	/* contains driver and semaphore information to perform I/O. */
+	if ( pContext == NULL )
+		return cOCT6100_DRIVER_READ_FAILED_0;
+
+	err = wanec_req_read(
+				pContext->ec_dev,
+				f_pReadParams->ulReadAddress,
+				f_pReadParams->pusReadData);
+	if (err){
+		return cOCT6100_DRIVER_READ_FAILED_1;
+	}
+
+	return cOCT6100_ERR_OK;
+}
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverReadOs
+
+Description:    Performs a read access to the chip. This function is accessible
+		only from the APIMI code entity (i.e. not from the API code
+		entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN OUT f_pReadParams		Pointer to structure containing the Params to the
+				read function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverReadOs(
+			IN OUT	tPOCT6100_READ_PARAMS	f_pReadParams )
+{
+
+	/* We assume that the interrupts are blocked during the 
+	Oct6100UserDriverReadApi calls and that the Oct6100UserDriverReadApi 
+	function is accessible in an interrupt context */
+	return Oct6100UserDriverReadApi( f_pReadParams );
+}
+
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverReadBurstApi
+
+Description:    Performs a burst of read accesses to the chip. The first read
+		is performed at the start address, and the address is
+		incremented by two for each subsequent read. The data is
+		retunred in an array provided by the user. This function is
+		accessible only from the API code entity (i.e. not from the
+		APIMI code entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN OUT f_pBurstParams		Pointer to structure containing the Params to the
+				read function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverReadBurstApi(
+			IN OUT	tPOCT6100_READ_BURST_PARAMS	f_pBurstParams )
+{
+	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
+	unsigned int	i, err;
+	unsigned short	*data;
+#if defined(__WINDOWS__)
+	unsigned char tmp_buf[OCT_TMP_MEMORY_SIZE];
+	int rc = SILENT;
+#endif
+
+	/*  The pProcessContext is there in case the user needs context information
+	in order to perform the access. Note that if it is used, the memory pointed 
+	by this pointer	must be allocated by the user beforehand. */
+	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pBurstParams->pProcessContext;
+
+	/* Check if driver context exists. In this implementation, the context */
+	/* contains driver and semaphore information to perform I/O. */
+	if ( pContext == NULL )
+		return cOCT6100_DRIVER_RBURST_FAILED_0;
+
+	/* In this case, the message is allocated dynamically since we do not know */
+	/* in advance the size of the array to be passed down to the driver. */
+#if defined(WAN_KERNEL)
+# if !defined(__WINDOWS__)
+	data = (unsigned short*)wan_malloc(f_pBurstParams->ulReadLength * sizeof(unsigned short));
+# else
+	VERIFY_DISPATCH_IRQL(rc);
+	if(rc){
+		//Memory allocation is invalid inside ISR, use a temp buffer.
+		if(f_pBurstParams->ulReadLength * sizeof(unsigned short) > OCT_TMP_MEMORY_SIZE){
+			DEBUG_EVENT("%s(): Memory requested (%d) bigger than 'temp' (%d) buffer!!\n",
+				__FUNCTION__, f_pBurstParams->ulReadLength * sizeof(unsigned short), OCT_TMP_MEMORY_SIZE);
+			return cOCT6100_DRIVER_WBURST_FAILED_1;
+		}
+		data = (unsigned short*)tmp_buf;
+	}else{
+		data = (unsigned short*)wan_malloc(f_pBurstParams->ulReadLength * sizeof(unsigned short));
+	}
+# endif
+#else
+	data = (unsigned short*)malloc(f_pBurstParams->ulReadLength * sizeof(unsigned short));
+#endif
+	if (data == NULL){
+		return cOCT6100_DRIVER_RBURST_FAILED_1;
+	}
+	err = wanec_req_read_burst(
+				pContext->ec_dev,
+				f_pBurstParams->ulReadAddress,
+				data,
+				f_pBurstParams->ulReadLength);	
+
+	/* Copy result to the user. */
+	if (!err){
+		for(i = 0; i < f_pBurstParams->ulReadLength; i++){
+			f_pBurstParams->pusReadData[i] = data[i];
+		}
+	}
+	
+	/* Cleanup allocated memory. */
+#if defined(WAN_KERNEL)
+# if !defined(__WINDOWS__)
+	wan_free(data);
+# else
+	rc = SILENT;
+	VERIFY_DISPATCH_IRQL(rc);
+	if(rc == 0){
+		wan_free(data);
+	}
+# endif
+#else
+	free(data);
+#endif
+
+	if (err){
+		return cOCT6100_DRIVER_RBURST_FAILED_2;
+	}
+
+	return cOCT6100_ERR_OK;
+}
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverReadBurstOs
+
+Description:    Performs a burst of read accesses to the chip. The first read
+		is performed at the start address, and the address is
+		incremented by two for each subsequent read. The data is
+		retunred in an array provided by the user. This function is
+		accessible only from the APIMI code entity (i.e. not from the
+		API code entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN OUT f_pBurstParams		Pointer to structure containing the Params to the
+				read function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverReadBurstOs(
+			IN OUT	tPOCT6100_READ_BURST_PARAMS	f_pBurstParams )
+{
+	/* We assume that the interrupts are blocked during the 
+	Oct6100UserDriverReadApi calls and that the  
+	Oct6100UserDriverReadBurstApi function is accessible 
+	in an interrupt context */
+	return Oct6100UserDriverReadBurstApi(f_pBurstParams);
+}
+
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_api: .oct6100_user.o.cmd
Only in wanec/oct6100_api/octdeviceapi/oct6100api/oct6100_api: sources
Only in wanec/oct6100_api/octdeviceapi/oct6100api/oct6100_apimi: CVS
Only in wanec.old/oct6100_api/octdeviceapi/oct6100api/oct6100_apimi: .oct6100_mask_interrupts.o.cmd
Only in wanec/oct6100_api/octdeviceapiw: CVS
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_freebsd: CVS
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: CVS
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_adpcm_chan.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_adpcm_chan.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_channel.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_channel.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_chip_open.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_chip_open.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_chip_stats.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_chip_stats.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_conf_bridge.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_conf_bridge.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_debug.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_debug.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_events.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_events.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_interrupts.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_interrupts.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_mask_interrupts.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_mask_interrupts.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_memory.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_memory.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_miscellaneous.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_miscellaneous.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_mixer.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_mixer.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_phasing_tsst.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_phasing_tsst.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_playout_buf.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_playout_buf.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_remote_debug.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_remote_debug.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_tlv.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_tlv.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_tone_detection.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_tone_detection.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_tsi_cnct.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_tsi_cnct.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_tsst.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_tsst.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_user.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: oct6100_user.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: octapi_bt0.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: octapi_bt0.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: octapi_largmath.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: octapi_largmath.o
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: octapi_llman.d
Only in wanec/oct6100_api/octdeviceapiw/oct6100_apiw_linux: octapi_llman.o
Only in wanec: oct6100_api.PR39
Only in wanec: oct6100_api.PR41
Only in wanec/oct6100_api.PR43/apilib/bt: CVS
Only in wanec/oct6100_api.PR43/apilib/bt: makefile
Only in wanec.old/oct6100_api.PR43/apilib/bt: .octapi_bt0.o.cmd
Only in wanec/oct6100_api.PR43/apilib/bt: sources
Only in wanec/oct6100_api.PR43/apilib: CVS
Only in wanec/oct6100_api.PR43/apilib/largmath: CVS
Only in wanec/oct6100_api.PR43/apilib/largmath: makefile
Only in wanec.old/oct6100_api.PR43/apilib/largmath: .octapi_largmath.o.cmd
Only in wanec/oct6100_api.PR43/apilib/largmath: sources
Only in wanec/oct6100_api.PR43/apilib/llman: CVS
Only in wanec/oct6100_api.PR43/apilib/llman: makefile
Only in wanec.old/oct6100_api.PR43/apilib/llman: .octapi_llman.o.cmd
Only in wanec/oct6100_api.PR43/apilib/llman: sources
Only in wanec/oct6100_api.PR43: CVS
Only in wanec/oct6100_api.PR43/include/apilib: CVS
Only in wanec/oct6100_api.PR43/include: CVS
Only in wanec/oct6100_api.PR43/include/oct6100api: CVS
diff -dur wanec.old/oct6100_api.PR43/include/octosdependant.h wanec/oct6100_api.PR43/include/octosdependant.h
--- wanec.old/oct6100_api.PR43/include/octosdependant.h	2006-10-06 14:46:50.000000000 -0400
+++ wanec/oct6100_api.PR43/include/octosdependant.h	2006-10-27 14:01:07.369927384 -0400
@@ -1,155 +1,159 @@
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-File: octosdependant.h
-
-    Copyright (c) 2001-2006 Octasic Inc.
-
-Description: 
-
-	This file is included to set target-specific constants.
-
-This file is part of the Octasic OCT6100 GPL API . The OCT6100 GPL API  is 
-free software; you can redistribute it and/or modify it under the terms of 
-the GNU General Public License as published by the Free Software Foundation; 
-either version 2 of the License, or (at your option) any later version.
-
-The OCT6100 GPL API is distributed in the hope that it will be useful, but 
-WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
-or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
-for more details. 
-
-You should have received a copy of the GNU General Public License 
-along with the OCT6100 GPL API; if not, write to the Free Software 
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-
-$Octasic_Release: OCT612xAPI-01.00-PR43 $
-
-$Octasic_Revision: 16 $
-
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-
-#ifndef __OCTOSDEPENDANT_H__
-#define __OCTOSDEPENDANT_H__
-
-
-/*--------------------------------------------------------------------------
-	C language
-----------------------------------------------------------------------------*/
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-
-/*****************************************************************************
-
-  Known define values
-
-	MSDEV:
-			WIN32		==	WINDOWS 32 bit app
-			__WIN32__	==	WINDOWS 32 bit app
-			_Windows	==	WINDOWS 16 bit app
-
-			_WINDOWS	==	Windows application .. not console
-			_DLL		==	Dll Application
-			_CONSOLE	==	Console Application .. no windows
-
-	BORLANDC
-			__TURBOC__		== Turbo Compiler
-			__BORLANDC__	== Borland compiler
-			__OS2__			== Borland OS2 compiler
-			_Windows		== Windows 16 bit app
-
-	GCC Compiler
-			__GNUC__		== GCC Compiler
-			__unix__		== Unix system 
-			__vax__			== Unix system 
-			unix			== Unix system
-			vax				== vax system
-
-	TORNADO
-			_VXWORKS_		==	VXWORK
-
-	ECOS/CYGWIN
-			_ECOS_			== eCos
-
-  	SOLARIS
-			_SOLARIS_		== Solaris
-
-*****************************************************************************/
-
-/* Machine endian type */
-
-#define OCT_MACH_LITTLE_ENDIAN		1
-#define OCT_MACH_BIG_ENDIAN			2
-
-/* Try to find current OCT_MACH_ENDIAN from compiler define values */
-#if !defined( MACH_TYPE_BIG_ENDIAN ) && !defined( MACH_TYPE_LITTLE_ENDIAN )
-
-	/* Look for intel */
-	#if defined( _M_IX86 )	
-		#define OCT_MACH_ENDIAN		OCT_MACH_LITTLE_ENDIAN
-	/* Look for PowerPC */
-	#elif defined( _M_MPPC  ) || defined( _M_PPC ) 
-		#define OCT_MACH_ENDIAN		OCT_MACH_BIG_ENDIAN
-	#elif defined( CPU )
-		#if CPU==PPC860 || CPU==SIMNT
-			#define OCT_MACH_ENDIAN		OCT_MACH_BIG_ENDIAN
-		#else
-			#define OCT_MACH_ENDIAN		OCT_MACH_LITTLE_ENDIAN	
-		#endif
-	/* Default is little endian */
-	#else
-		#define OCT_MACH_ENDIAN		OCT_MACH_LITTLE_ENDIAN	
-	#endif
-#else
-	#if defined( MACH_TYPE_BIG_ENDIAN )
-		#define OCT_MACH_ENDIAN		OCT_MACH_BIG_ENDIAN
-	#else
-		#define OCT_MACH_ENDIAN		OCT_MACH_LITTLE_ENDIAN	
-	#endif
-#endif
-
-/* Find system type if not already defined */
-#if !defined( OCT_NTDRVENV ) && !defined( OCT_VXENV ) && !defined( OCT_WINENV )
-
-#if defined( WIN32 ) || defined( __WIN32__ ) ||	defined( _WIN32_ ) || defined( WIN32S )
-	/* Verif if building a win32 driver */
-	#if ( defined( WIN32 ) && WIN32==100 )
-		#define OCT_NTDRVENV
-	#else
-		#define OCT_WINENV
-	#endif
-#elif defined( _VXWORKS_ )
-	#define OCT_VXENV
-#elif defined( _ECOS_ )
-	#define OCT_ECOSENV
-#elif defined( _SOLARIS_ )
-	#define OCT_SOLARISENV
-#elif defined( _LINUX_ )
-	#define OCT_LINUXENV
-#else
-	/* Unknown environment */
-	#define OCT_UNKNOWNENV
-#endif	/* WIN env */
-
-#endif /* Already defined */
-
-#if defined( __KERNEL__ ) && defined( OCT_LINUXENV )
-#define OCT_LINUXDRVENV
-#endif
-
-#ifdef _DEBUG
-#define OCT_OPT_USER_DEBUG
-#endif
-
-/*--------------------------------------------------------------------------
-	C language
-----------------------------------------------------------------------------*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif	/* __OCTOSDEPENDANT_H__ */
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+File: octosdependant.h
+
+    Copyright (c) 2001-2006 Octasic Inc.
+
+Description: 
+
+	This file is included to set target-specific constants.
+
+This file is part of the Octasic OCT6100 GPL API . The OCT6100 GPL API  is 
+free software; you can redistribute it and/or modify it under the terms of 
+the GNU General Public License as published by the Free Software Foundation; 
+either version 2 of the License, or (at your option) any later version.
+
+The OCT6100 GPL API is distributed in the hope that it will be useful, but 
+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
+or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
+for more details. 
+
+You should have received a copy of the GNU General Public License 
+along with the OCT6100 GPL API; if not, write to the Free Software 
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+
+$Octasic_Release: OCT612xAPI-01.00-PR43 $
+
+$Octasic_Revision: 16 $
+
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+
+#ifndef __OCTOSDEPENDANT_H__
+#define __OCTOSDEPENDANT_H__
+
+
+/*--------------------------------------------------------------------------
+	C language
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+/*****************************************************************************
+
+  Known define values
+
+	MSDEV:
+			WIN32		==	WINDOWS 32 bit app
+			__WIN32__	==	WINDOWS 32 bit app
+			_Windows	==	WINDOWS 16 bit app
+
+			_WINDOWS	==	Windows application .. not console
+			_DLL		==	Dll Application
+			_CONSOLE	==	Console Application .. no windows
+
+	BORLANDC
+			__TURBOC__		== Turbo Compiler
+			__BORLANDC__	== Borland compiler
+			__OS2__			== Borland OS2 compiler
+			_Windows		== Windows 16 bit app
+
+	GCC Compiler
+			__GNUC__		== GCC Compiler
+			__unix__		== Unix system 
+			__vax__			== Unix system 
+			unix			== Unix system
+			vax				== vax system
+
+	TORNADO
+			_VXWORKS_		==	VXWORK
+
+	ECOS/CYGWIN
+			_ECOS_			== eCos
+
+  	SOLARIS
+			_SOLARIS_		== Solaris
+
+*****************************************************************************/
+
+/* Machine endian type */
+
+#define OCT_MACH_LITTLE_ENDIAN		1
+#define OCT_MACH_BIG_ENDIAN			2
+
+/* Try to find current OCT_MACH_ENDIAN from compiler define values */
+#if !defined( MACH_TYPE_BIG_ENDIAN ) && !defined( MACH_TYPE_LITTLE_ENDIAN )
+
+	/* Look for intel */
+	#if defined( _M_IX86 )	
+		#define OCT_MACH_ENDIAN		OCT_MACH_LITTLE_ENDIAN
+	/* Look for PowerPC */
+	#elif defined( _M_MPPC  ) || defined( _M_PPC ) 
+		#define OCT_MACH_ENDIAN		OCT_MACH_BIG_ENDIAN
+	#elif defined( CPU )
+		#if CPU==PPC860 || CPU==SIMNT
+			#define OCT_MACH_ENDIAN		OCT_MACH_BIG_ENDIAN
+		#else
+			#define OCT_MACH_ENDIAN		OCT_MACH_LITTLE_ENDIAN	
+		#endif
+	/* Default is little endian */
+	#else
+		#define OCT_MACH_ENDIAN		OCT_MACH_LITTLE_ENDIAN	
+	#endif
+#else
+	#if defined( MACH_TYPE_BIG_ENDIAN )
+		#define OCT_MACH_ENDIAN		OCT_MACH_BIG_ENDIAN
+	#else
+		#define OCT_MACH_ENDIAN		OCT_MACH_LITTLE_ENDIAN	
+	#endif
+#endif
+
+/* Find system type if not already defined */
+#if !defined( OCT_NTDRVENV ) && !defined( OCT_VXENV ) && !defined( OCT_WINENV )
+
+#if defined( WIN32 ) || defined( __WIN32__ ) ||	defined( _WIN32_ ) || defined( WIN32S )
+	/* Verif if building a win32 driver */
+	#if ( defined( WIN32 ) && WIN32==100 )
+		#define OCT_NTDRVENV
+	#else
+		#define OCT_WINENV
+	#endif
+#elif defined( _VXWORKS_ )
+	#define OCT_VXENV
+#elif defined( _ECOS_ )
+	#define OCT_ECOSENV
+#elif defined( _SOLARIS_ )
+	#define OCT_SOLARISENV
+#elif defined( _LINUX_ )
+	#define OCT_LINUXENV
+#else
+	/* Unknown environment */
+	#define OCT_UNKNOWNENV
+#endif	/* WIN env */
+
+#endif /* Already defined */
+
+#if defined(__WINDOWS__)
+#define OCT_NTDRVENV
+#endif
+
+#if defined( __KERNEL__ ) && defined( OCT_LINUXENV )
+#define OCT_LINUXDRVENV
+#endif
+
+#ifdef _DEBUG
+#define OCT_OPT_USER_DEBUG
+#endif
+
+/*--------------------------------------------------------------------------
+	C language
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* __OCTOSDEPENDANT_H__ */
Only in wanec/oct6100_api.PR43/include/octrpc: CVS
diff -dur wanec.old/oct6100_api.PR43/include/octtype.h wanec/oct6100_api.PR43/include/octtype.h
--- wanec.old/oct6100_api.PR43/include/octtype.h	2006-10-06 14:46:50.000000000 -0400
+++ wanec/oct6100_api.PR43/include/octtype.h	2006-10-27 14:01:07.369927384 -0400
@@ -1,153 +1,157 @@
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-File: octtype.h
-
-    Copyright (c) 2001-2006 Octasic Inc.
-
-Description: 
-
-	This file defines the base storage types.
-
-This file is part of the Octasic OCT6100 GPL API . The OCT6100 GPL API  is 
-free software; you can redistribute it and/or modify it under the terms of 
-the GNU General Public License as published by the Free Software Foundation; 
-either version 2 of the License, or (at your option) any later version.
-
-The OCT6100 GPL API is distributed in the hope that it will be useful, but 
-WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
-or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
-for more details. 
-
-You should have received a copy of the GNU General Public License 
-along with the OCT6100 GPL API; if not, write to the Free Software 
-Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-
-$Octasic_Release: OCT612xAPI-01.00-PR43 $
-
-$Octasic_Revision: 18 $
-
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-#ifndef __OCTTYPE_H__
-#define __OCTTYPE_H__
-
-/*--------------------------------------------------------------------------
-	C language
-----------------------------------------------------------------------------*/
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*--------------------------------------------------------------------------
-	Include target-specific header if available 
-----------------------------------------------------------------------------*/
-#if defined( OCT_NTDRVENV )
-	#include "octtypentdrv.h"		/* All NT driver typedef */
-#elif defined( OCT_WINENV )	
-	#include "octtypewin.h"			/* All Win32 typedef */
-#elif defined( OCT_VXENV )
-	#include "octtypevx.h"			/* All VxWorks typedef */
-#else
-/*--------------------------------------------------------------------------
-	No target-specific header  available 
-----------------------------------------------------------------------------*/
-
-/*****************************  DEFINES  *************************************/
-/* 16-bit integer */
-typedef unsigned short	UINT16;
-typedef signed short	INT16;
-typedef unsigned short	*PUINT16;
-typedef signed short	*PINT16;
-
-/* 8-bit integer */
-typedef unsigned char	UINT8;
-typedef signed char		INT8;
-typedef signed char		OCT_INT8;
-typedef unsigned char	*PUINT8;
-typedef signed char		*PINT8;
-
-
-/* 32 bit integer */
-typedef unsigned int	UINT32;
-typedef signed int		INT32;
-typedef INT32 *			PINT32;
-typedef UINT32 *		PUINT32;
-
-/* Long integer */
-typedef signed long		LONG;
-typedef unsigned long	ULONG;
-typedef	long *			PLONG;
-typedef	unsigned long *	PULONG;
-
-/* Short integer */
-typedef	short			SHORT;
-typedef	unsigned short	USHORT;
-typedef	short *			PSHORT;
-typedef	unsigned short *PUSHORT;
-
-/* 8-bit integer*/
-typedef unsigned char	BYTE;
-typedef	BYTE *			PBYTE;
-typedef unsigned char	UCHAR;
-
-/* Character and strings */
-typedef char			CHAR;
-typedef	CHAR 			SZ;
-typedef	CHAR *			PSZ;
-typedef	CHAR *			PCHAR;
-
-/* Double integers */
-typedef	double			DOUBLE;
-typedef	double *		PDOUBLE;
-typedef	float			FLOAT;
-typedef	float *			PFLOAT;
-
-typedef	void			VOID;
-typedef	void *			PVOID;
-
-/* Booleans */
-typedef	int				BOOL;
-typedef	BOOL *			PBOOL;
-
-/* Integers */
-typedef	int				INT;
-typedef	int *			PINT;
-typedef	unsigned int	UINT;
-typedef	unsigned int *	PUINT;
-
-/* Define pseudo-keywords IN and OUT if not defined yet */
-#ifndef IN
-#define IN		/* IN param */
-#endif
-
-#ifndef OUT
-#define OUT		/* OUT param */
-#endif
-
-/* LONG LONG */
-#define LLONG			signed long long
-#define PLLONG			signed long long *
-#define ULLONG			unsigned long long
-#define PULLONG			unsigned long long *
-
-#ifndef OPT
-#define OPT		/* OPT param */
-#endif
-
-typedef	PSZ *	PPSZ;
-
-#ifndef NULL
-#define NULL 0
-#endif
-
-#endif
-
-/*--------------------------------------------------------------------------
-	C language
-----------------------------------------------------------------------------*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif	/* __OCTTYPE_H__ */
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+File: octtype.h
+
+    Copyright (c) 2001-2006 Octasic Inc.
+
+Description: 
+
+	This file defines the base storage types.
+
+This file is part of the Octasic OCT6100 GPL API . The OCT6100 GPL API  is 
+free software; you can redistribute it and/or modify it under the terms of 
+the GNU General Public License as published by the Free Software Foundation; 
+either version 2 of the License, or (at your option) any later version.
+
+The OCT6100 GPL API is distributed in the hope that it will be useful, but 
+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
+or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
+for more details. 
+
+You should have received a copy of the GNU General Public License 
+along with the OCT6100 GPL API; if not, write to the Free Software 
+Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+
+$Octasic_Release: OCT612xAPI-01.00-PR43 $
+
+$Octasic_Revision: 18 $
+
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+#ifndef __OCTTYPE_H__
+#define __OCTTYPE_H__
+
+/*--------------------------------------------------------------------------
+	C language
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*--------------------------------------------------------------------------
+	Include target-specific header if available 
+----------------------------------------------------------------------------*/
+#if defined( OCT_NTDRVENV )
+	#include "octtypentdrv.h"		/* All NT driver typedef */
+#elif defined( OCT_WINENV )	
+	#include "octtypewin.h"			/* All Win32 typedef */
+#elif defined( OCT_VXENV )
+	#include "octtypevx.h"			/* All VxWorks typedef */
+//#else
+#endif
+/*--------------------------------------------------------------------------
+	No target-specific header  available 
+----------------------------------------------------------------------------*/
+
+/*****************************  DEFINES  *************************************/
+/* 16-bit integer */
+typedef unsigned short	UINT16;
+typedef signed short	INT16;
+typedef unsigned short	*PUINT16;
+typedef signed short	*PINT16;
+
+/* 8-bit integer */
+typedef unsigned char	UINT8;
+typedef signed char		INT8;
+typedef signed char		OCT_INT8;
+typedef unsigned char	*PUINT8;
+typedef signed char		*PINT8;
+
+
+/* 32 bit integer */
+typedef unsigned int	UINT32;
+typedef signed int		INT32;
+typedef INT32 *			PINT32;
+typedef UINT32 *		PUINT32;
+
+/* Long integer */
+typedef signed long		LONG;
+typedef unsigned long	ULONG;
+typedef	long *			PLONG;
+typedef	unsigned long *	PULONG;
+
+/* Short integer */
+typedef	short			SHORT;
+typedef	unsigned short	USHORT;
+typedef	short *			PSHORT;
+typedef	unsigned short *PUSHORT;
+
+/* 8-bit integer*/
+typedef unsigned char	BYTE;
+typedef	BYTE *			PBYTE;
+typedef unsigned char	UCHAR;
+
+/* Character and strings */
+typedef char			CHAR;
+typedef	CHAR 			SZ;
+typedef	CHAR *			PSZ;
+typedef	CHAR *			PCHAR;
+
+/* Double integers */
+typedef	double			DOUBLE;
+typedef	double *		PDOUBLE;
+typedef	float			FLOAT;
+typedef	float *			PFLOAT;
+
+#if !defined(__WINDOWS__) 
+typedef	void			VOID;
+#else
+#define VOID			void
+#endif
+typedef	void *			PVOID;
+
+/* Booleans */
+typedef	int				BOOL;
+typedef	BOOL *			PBOOL;
+
+/* Integers */
+typedef	int				INT;
+typedef	int *			PINT;
+typedef	unsigned int	UINT;
+typedef	unsigned int *	PUINT;
+
+/* Define pseudo-keywords IN and OUT if not defined yet */
+#ifndef IN
+#define IN		/* IN param */
+#endif
+
+#ifndef OUT
+#define OUT		/* OUT param */
+#endif
+
+/* LONG LONG */
+#define LLONG			signed long long
+#define PLLONG			signed long long *
+#define ULLONG			unsigned long long
+#define PULLONG			unsigned long long *
+
+#ifndef OPT
+#define OPT		/* OPT param */
+#endif
+
+typedef	PSZ *	PPSZ;
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+
+/*--------------------------------------------------------------------------
+	C language
+----------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* __OCTTYPE_H__ */
Only in wanec/oct6100_api.PR43/include: octtypentdrv.h
Only in wanec/oct6100_api.PR43/octdeviceapi: CVS
Only in wanec/oct6100_api.PR43/octdeviceapi/oct6100api: CVS
Only in wanec/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: CVS
Only in wanec/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: makefile
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_adpcm_chan.o.cmd
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_channel.o.cmd
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_chip_open.o.cmd
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_chip_stats.o.cmd
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_conf_bridge.o.cmd
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_debug.o.cmd
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_events.o.cmd
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_interrupts.o.cmd
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_memory.o.cmd
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_miscellaneous.o.cmd
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_mixer.o.cmd
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_phasing_tsst.o.cmd
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_playout_buf.o.cmd
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_remote_debug.o.cmd
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_tlv.o.cmd
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_tone_detection.o.cmd
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_tsi_cnct.o.cmd
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_tsst.o.cmd
diff -dur wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api/oct6100_user.c wanec/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api/oct6100_user.c
--- wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api/oct6100_user.c	2006-10-06 14:46:50.000000000 -0400
+++ wanec/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api/oct6100_user.c	2006-10-27 14:01:07.383925256 -0400
@@ -1,1043 +1,1109 @@
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-File: oct6100_user.c
-
-	Copyright (c) 2001 Octasic Inc. All rights reserved.
-    
-Description: 
-
-	This file contains the functions provided by the user.
-
-This source code is Octasic Confidential. Use of and access to this code
-is covered by the Octasic Device Enabling Software License Agreement. 
-Acknowledgement of the Octasic Device Enabling Software License was 
-required for access to this code. A copy was also provided with the release.
-
-
-$Octasic_Release: OCT612xAPI-01.00-PR37 $
-
-$Octasic_Revision: 25 $
-
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-
-
-/*****************************  INCLUDE FILES  *******************************/
-
-
-/* System specific includes */
-#if defined(WAN_EC_USER)
-# include <unistd.h>
-# include <stdio.h>
-# include <stdlib.h>
-# include <time.h>
-# include <sys/fcntl.h>
-# include <sys/time.h>
-# include <sys/stat.h>
-# include <sys/types.h>
-# include <sys/ipc.h>
-# include <sys/sem.h>
-# include <sys/queue.h>
-# include <getopt.h>
-# include <limits.h>
-# include <errno.h>
-# include <memory.h>
-# include <signal.h>
-# include <semaphore.h>
-# include <sys/ioctl.h>
-# if defined(__LINUX__)
-#  include <linux/wanpipe_defines.h>
-#  include <linux/wanpipe_cfg.h>
-# elif defined(__FreeBSD__) || defined(__OpenBSD__)
-#  include <net/wanpipe_defines.h>
-#  include <net/wanpipe_cfg.h>
-# endif
-# include "oct6100api/oct6100_apiud.h"
-# include "oct6100api/oct6100_errors.h"
-# include "oct6100api/oct6100_api.h"
-# include "oct6100_version.h"
-# include "wanec_iface.h"
-#else
-# if defined(__LINUX__)
-#  include <linux/wanpipe_includes.h>
-#  include <linux/wanpipe.h>
-# else
-#  include <wanpipe_includes.h>
-#  include <wanpipe.h>
-# endif
-
-#include "oct6100api/oct6100_apiud.h"
-#include "oct6100api/oct6100_errors.h"
-
-#include "oct6100api/oct6100_api.h"
-#include "oct6100_version.h"
-
-# include "wanec_iface.h"
-#endif
-
-extern u_int32_t wanec_req_write(void*, u_int32_t write_addr, u_int16_t write_data);
-extern u_int32_t wanec_req_write_smear(void*, u_int32_t addr, u_int16_t data, u_int32_t len);
-extern u_int32_t wanec_req_write_burst(void*, u_int32_t addr, u_int16_t *data, u_int32_t len);
-extern u_int32_t wanec_req_read(void*, u_int32_t addr, u_int16_t *data);
-extern u_int32_t wanec_req_read_burst(void*, u_int32_t addr, u_int16_t *data, u_int32_t len);
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserGetTime
-
-Description:	Returns the system time in us.
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN OUT f_pTime		Pointer to structure in which the time is returned.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserGetTime(
-
-			IN OUT tPOCT6100_GET_TIME	f_pTime )
-{
-	clock_t		ulClockTicks;
-	struct timeval	TimeVal;
-	static UINT32	ulWallTimeUsHigh = 0;
-	static UINT32	ulWallTimeUsLow = 0;
-
-	if( !f_pTime )
-		return cOCT6100_GET_TIME_FAILED_0;
-
-	/* Retrieve clock tick */
-#if defined(WAN_KERNEL)
-	wan_getcurrenttime( &TimeVal.tv_sec, &TimeVal.tv_usec );
-#else
-	gettimeofday( &TimeVal, NULL );
-#endif
-	/* ulClockTicks = ( TimeVal.tv_sec * 1000000 ) + ( TimeVal.tv_usec ); */
-	/* Create a value im ms (as clock does) */
-	ulClockTicks = ( TimeVal.tv_sec * 1000 ) + ( TimeVal.tv_usec /1000 );
-
-	/* move to micro sec */
-	ulClockTicks *= 1000;
-
-	/* Did it wrap ? */
-	if ( (UINT32)ulClockTicks < ulWallTimeUsLow )
-	{
-		/* Yes, so increment MSB */
-		ulWallTimeUsHigh++;
-	}
-
-	f_pTime->aulWallTimeUs[ 0 ] = ulClockTicks;
-	f_pTime->aulWallTimeUs[ 1 ] = ulWallTimeUsHigh;
-	ulWallTimeUsLow = f_pTime->aulWallTimeUs[ 0 ];
-
-	return cOCT6100_ERR_OK;
-}
-
-
-
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserMemSet
-
-Description:	Sets f_ulLength bytes pointed to by f_pAddress to f_ulPattern.
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserMemSet(
-			IN	PVOID	f_pAddress,
-			IN	UINT32	f_ulPattern,
-			IN	UINT32	f_ulLength )
-{
-
-	memset( f_pAddress, f_ulPattern, f_ulLength );
-
-	return cOCT6100_ERR_OK;
-}
-
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserMemCopy
-
-Description:	Copy f_ulLength bytes from f_pSource to f_pDestination.
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserMemCopy(
-			IN	PVOID	f_pDestination,
-			IN	PVOID	f_pSource,
-			IN	UINT32	f_ulLength )
-{
-
-	memcpy( f_pDestination, f_pSource, f_ulLength );
-
-	return cOCT6100_ERR_OK;
-}
-
-
-#if !defined(WAN_KERNEL)
-static void SigArlmHandler()
-{
-}
-#endif
-
-#if defined(__GNU_LIBRARY__) && !defined(_SEM_SEMUN_UNDEFINED) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(WAN_KERNEL)
-/* union semun is defined by including <sys/sem.h> */
-#else
-/* according to X/OPEN we have to define it ourselves */
-union semun {
-	int val;                  /* value for SETVAL */
-	struct semid_ds *buf;     /* buffer for IPC_STAT, IPC_SET */
-	unsigned short *array;    /* array for GETALL, SETALL */
-                              /* Linux specific part: */
-	struct seminfo *__buf;    /* buffer for IPC_INFO */
-};
-#endif
-
-typedef struct _SEM_FILE_INF_
-{
-	UINT32		ulMainProcessId;
-	UINT32		ulUsageCount;
-
-} tSEM_FILE_INF, *tPSEM_FILE_INF;
-
-typedef struct _SEM_INF_
-{
-	INT			SemId;
-	CHAR		szFileName[PATH_MAX];
-
-} tSEM_INF, *tPSEM_INF;
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserCreateSerializeObject
-
-Description:	Creates a serialization object. The serialization object is
-				seized via the Oct6100UserSeizeSerializeObject function.
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN OUT f_pCreate		Pointer to structure in which the serialization object's
-				handle is returned.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserCreateSerializeObject(
-
-		IN OUT tPOCT6100_CREATE_SERIALIZE_OBJECT	f_pCreate )
-{
-
-#if !defined(WAN_KERNEL)
-
-	UINT32					ulRc = cOCT6100_ERR_OK;
-	INT					SemId;
-	FILE *					hSemFile = NULL;
-	BOOL					fFileCreated = FALSE;
-	key_t					Key;
-	int					iSemCnt = 1;
-	tPSEM_INF				pSemInf = NULL;
-	union semun 				SemArg;
-	tSEM_FILE_INF				SemFileInf;
-	struct stat				FileStat;
-	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
-
-	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pCreate->pProcessContext;
-
-	if ( ( f_pCreate == NULL ) || ( f_pCreate->pszSerialObjName == NULL )  )
-		return cOCT6100_CREATE_SERIAL_FAILED_0;
-
-	/* Alloc a sem inf structure */
-	pSemInf = (tPSEM_INF)malloc( sizeof(tSEM_INF) );
-
-	/* Check if malloc failed!!! */
-	if ( pSemInf == NULL )
-		return cOCT6100_CREATE_SERIAL_FAILED_0; /* No memory. */
-
-	snprintf( pSemInf->szFileName, PATH_MAX, "/tmp/%s", f_pCreate->pszSerialObjName );
-
-	/* File exist? */
-	if( stat( pSemInf->szFileName, &FileStat ) )
-	{
-		/* Not main process, this file must exist */
-		if ( pContext->fMainProcess == FALSE )
-		{
-			/* The file does not exist, and we are not the main process. */
-			ulRc = cOCT6100_CREATE_SERIAL_FAILED_1;
-		}
-		else
-		{
-			/* create the file */
-			hSemFile = fopen( pSemInf->szFileName, "w+b" );
-			if( !hSemFile )
-			{
-				ulRc = cOCT6100_CREATE_SERIAL_FAILED_2;
-			}
-			else
-			{
-				fFileCreated = TRUE;
-				memset( &SemFileInf, 0x0, sizeof(SemFileInf) );
-			}
-		}
-		SemFileInf.ulMainProcessId = getpid();
-	}
-	else
-	{
-		/* The semaphore exists.  Open it. */
-		hSemFile = fopen( pSemInf->szFileName, "r+b" );
-		/* Retrieve info from file */
-		if ( sizeof(SemFileInf) != fread( &SemFileInf, 1, sizeof(SemFileInf), hSemFile ) )
-		{
-			ulRc = cOCT6100_CREATE_SERIAL_FAILED_2;
-		}
-		/* rewind file */
-		rewind( hSemFile );
-	}
-
-	if ( cOCT6100_ERR_OK == ulRc )
-	{
-		/* This will create a key with upper bits set to 'K' ( 0x4b ) */
-		Key = ftok( pSemInf->szFileName, 'K' );
-
-		if ( -1 == Key )
-		{
-			ulRc = cOCT6100_CREATE_SERIAL_FAILED_2;
-		}
-	}
-
-	if ( cOCT6100_ERR_OK == ulRc )
-	{
-		/* Get the semaphore or create it */
-		SemId = semget( Key, iSemCnt, IPC_CREAT | 0666 /* | IPC_EXCL */ );
-
-		if ( -1 == SemId )
-		{
-			ulRc = cOCT6100_CREATE_SERIAL_FAILED_3;
-		}
-	}
-
-	if ( cOCT6100_ERR_OK == ulRc )
-	{
-		SemArg.val = 1;
-		iSemCnt = 0;
-		if ( 0 == semctl( SemId, iSemCnt, SETVAL, SemArg ))
-		{
-			/* Store handle and id */
-			pSemInf->SemId = SemId;
-
-			/* increment usage count */
-			SemFileInf.ulUsageCount++;
-			/* write file */
-			if ( sizeof(SemFileInf) != fwrite( &SemFileInf, 1, sizeof(SemFileInf), hSemFile ) )
-			{
-				ulRc = cOCT6100_CREATE_SERIAL_FAILED_4;
-			}
-			else
-			{
-				/* commit write */
-				fflush( hSemFile );
-				fclose( hSemFile );
-				signal( SIGALRM, SigArlmHandler );
-				
-				/* Keep pointer to semaphore information. */
-				f_pCreate->ulSerialObjHndl = (UINT32)pSemInf;	
-			}
-		}
-		else
-		{
-			ulRc = cOCT6100_CREATE_SERIAL_FAILED_4;
-		}
-	}
-	
-	/* Any errors ? */
-	if ( cOCT6100_ERR_OK != ulRc )
-	{
-		if ( -1 != SemId )
-		{
-			/* remove semaphore */
-			semctl( SemId, 0, IPC_RMID, SemArg );    
-		}
-		if ( NULL != hSemFile )
-		{
-			fclose( hSemFile );
-		}
-
-		if ( pSemInf )
-		{
-			if ( fFileCreated )
-			{
-				unlink( pSemInf->szFileName );
-			}
-
-			free( pSemInf );
-		}
-	}
-
-	return ulRc;
-#else
-
-	return cOCT6100_ERR_OK;
-#endif
-}
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDestroySerializeObject
-
-Description:	Destroys the indicated serialization object.
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN f_pDestroy			Pointer to structure containing the handle of the
-				serialization object.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDestroySerializeObject(
-
-			IN tPOCT6100_DESTROY_SERIALIZE_OBJECT		f_pDestroy )
-{	
-
-#if !defined(WAN_KERNEL)
-	UINT32		ulRc = cOCT6100_ERR_OK;
-	tPSEM_INF	pSemInf;
-
-	if ( ( f_pDestroy == NULL ) || ( f_pDestroy->ulSerialObjHndl == 0x0 ) )
-		return cOCT6100_DESTROY_SERIAL_FAILED_0;
-
-	pSemInf = (tPSEM_INF)(f_pDestroy->ulSerialObjHndl);
-
-	/* Check mutex handle */
-	if ( -1 != pSemInf->SemId )
-	{
-		FILE *			hSemFile = NULL;
-		tSEM_FILE_INF	SemFileInf;
-
-		/* Default is failure */
-		ulRc = cOCT6100_DESTROY_SERIAL_FAILED_0;
-
-		hSemFile = fopen( pSemInf->szFileName, "rb" );
-
-		if ( hSemFile )
-		{
-			/* read sem file inf */
-			if ( sizeof(SemFileInf) == fread( &SemFileInf, 1, sizeof(SemFileInf), hSemFile ) )
-			{
-				/* remove a link on that sem */
-				if ( SemFileInf.ulUsageCount > 0 )
-				{
-					SemFileInf.ulUsageCount--;
-				}
-
-				/* Last reference gone ? */
-				if( !SemFileInf.ulUsageCount )
-				{
-					union semun 	SemArg;
-
-					/* Close semaphore, this must be called when no one is waiting on sem */
-					if( semctl( pSemInf->SemId, 0, IPC_RMID, SemArg ) != -1 )
-					{
-						/* Close file */
-						fclose( hSemFile );
-						/* delete file */
-						unlink( pSemInf->szFileName );
-						/* release memory */
-						free( pSemInf );
-
-						/* return done */
-						f_pDestroy->ulSerialObjHndl = 0x0;
-						ulRc = cOCT6100_ERR_OK;
-					}
-				}
-				else
-				{
-					/* commit change */
-					rewind( hSemFile );
-					fwrite( &SemFileInf, 1, sizeof(SemFileInf), hSemFile );
-					/* commit write */
-					fflush( hSemFile );
-					fclose( hSemFile );
-					free( pSemInf );
-					/* If not in the main process, nothing much to do ... */
-					f_pDestroy->ulSerialObjHndl = 0x0;
-					ulRc = cOCT6100_ERR_OK;
-				}
-			}
-		}
-	}
-
-	return ulRc;
-#else
-
-	return cOCT6100_ERR_OK;
-#endif
-}
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserSeizeSerializeObject
-
-Description:	Seizes the indicated serialization object.
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN f_pSeize			Pointer to structure containing the handle of the
-				serialization object.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserSeizeSerializeObject(
-
-			IN tPOCT6100_SEIZE_SERIALIZE_OBJECT			f_pSeize )
-{
-
-#if !defined(WAN_KERNEL)
-	UINT32			ulRc = cOCT6100_ERR_OK;
-	tPSEM_INF		pSemInf;
-
-	if( f_pSeize == NULL )
-		return cOCT6100_SEIZE_SERIAL_FAILED_0;
-
-	if ( f_pSeize->ulSerialObjHndl == 0 )
-		return cOCT6100_SEIZE_SERIAL_FAILED_0;
-
-	pSemInf = (tPSEM_INF)f_pSeize->ulSerialObjHndl;
-
-	/* Check mutex handle */
-	if ( pSemInf )
-	{
-		INT			iRes = 0;
-		struct itimerval	TimerSetting;
-
-		ulRc = cOCT6100_SEIZE_SERIAL_FAILED_1;
-		
-		/* Check if must create a timer. */
-		if( cOCT6100_WAIT_INFINITELY != f_pSeize->ulTryTimeMs )
-		{
-			/* Set the alarm */
-			TimerSetting.it_value.tv_sec = ( f_pSeize->ulTryTimeMs / 1000 );
-			TimerSetting.it_value.tv_usec = ( f_pSeize->ulTryTimeMs % 1000 ) * 1000;
-			/* No repeat please! */
-			TimerSetting.it_interval.tv_sec = 0;
-			TimerSetting.it_interval.tv_usec = 0;
-
-			iRes = setitimer( ITIMER_REAL, &TimerSetting, NULL );
-		}
-		
-		if( iRes != -1 )
-		{
-			/* Timer is armed! */
-			struct sembuf LockSEM[1] = { { 0, -1, SEM_UNDO } };
-
-			iRes = semop( pSemInf->SemId, LockSEM, 1 );
-
-			if( iRes == -1 )
-			{
-				switch( errno )
-				{
-					case EINTR:
-						ulRc = cOCT6100_SEIZE_SERIAL_FAILED_2;
-						break;
-					default:
-						break;
-				}
-			}
-			else
-			{
-				ulRc = cOCT6100_ERR_OK;
-			}
-			
-			if( cOCT6100_WAIT_INFINITELY != f_pSeize->ulTryTimeMs )
-			{
-				/* Disarm timer */
-				TimerSetting.it_value.tv_sec = 0;
-				TimerSetting.it_value.tv_usec = 0;
-
-				setitimer( ITIMER_REAL, &TimerSetting, NULL );
-			}
-		}
-	}
-	return( ulRc );
-#else
-	return cOCT6100_ERR_OK;
-
-#endif
-
-}
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserReleaseSerializeObject
-
-Description:	Releases the indicated serialization object.
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN f_pRelease			Pointer to structure containing the handle of the
-				serialization object.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserReleaseSerializeObject(
-
-			IN tPOCT6100_RELEASE_SERIALIZE_OBJECT		f_pRelease )
-{
-
-#if !defined(WAN_KERNEL)
-	UINT32		ulRc = cOCT6100_ERR_OK;
-	tPSEM_INF	pSemInf;
-
-	if( f_pRelease == NULL )
-		return cOCT6100_RELEASE_SERIAL_FAILED_0;
-
-	if ( f_pRelease->ulSerialObjHndl == 0 )
-		return cOCT6100_RELEASE_SERIAL_FAILED_0;
-
-	pSemInf = (tPSEM_INF)f_pRelease->ulSerialObjHndl;
-
-	/* Check mutex handle */
-	if ( pSemInf )
-	{
-		struct sembuf UnlockSEM[1] = { { 0, 1, SEM_UNDO } };
-		int iRes;
-		
-		ulRc = cOCT6100_ERR_OK;
-
-		iRes = semop( pSemInf->SemId, UnlockSEM, 1 );
-
-		if( iRes == -1 )
-		{
-			ulRc = cOCT6100_RELEASE_SERIAL_FAILED_1;
-		}
-	}
-
-	return( ulRc );
-#else
-
-	return cOCT6100_ERR_OK;
-#endif
-
-}
-
-
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverWriteApi
-
-Description:    Performs a write access to the chip. This function is
-		accessible only from the API code entity (i.e. not from the
-		APIMI code entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN f_pWriteParams		Pointer to structure containing the Params to the
-				write function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverWriteApi(
-			IN	tPOCT6100_WRITE_PARAMS	f_pWriteParams )
-{
-	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
-	unsigned int				err;
-
-	/*  The pProcessContext is there in case the user needs context information
-	in order to perform the access. Note that if it is used, the memory pointed 
-	by this pointer	must be allocated by the user beforehand. */
-	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pWriteParams->pProcessContext;
-
-	/* Check if driver context exists. In this implementation, the context */
-	/* contains driver and semaphore information to perform I/O. */
-	if ( pContext == NULL )
-		return cOCT6100_DRIVER_WRITE_FAILED_0;
-
-	err = wanec_req_write(
-				pContext->ec_dev,
-				f_pWriteParams->ulWriteAddress,
-				f_pWriteParams->usWriteData);
-	if (err){
-		return cOCT6100_DRIVER_WRITE_FAILED_1;
-	}
-	return cOCT6100_ERR_OK;
-}
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverWriteOs
-
-Description:    Performs a write access to the chip. This function is
-		accessible only from the APIMI code entity (i.e. not from the
-		API code entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN f_pWriteParams		Pointer to structure containing the Params to the
-				write function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverWriteOs(
-			IN	tPOCT6100_WRITE_PARAMS	f_pWriteParams )
-{
-
-	/* We assume that the interrupts are blocked during the 
-	Oct6100UserDriverWriteApi calls and that the Oct6100UserDriverWriteApi 
-	function is accessible in an interrupt context */
-
-	return Oct6100UserDriverWriteApi( f_pWriteParams );
-}
-
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverWriteSmearApi
-
-Description:    Performs a series of write accesses to the chip. The same data
-		word is written to a series of addresses. The writes begin at
-		the start address, and the address is incremented by the
-		indicated amount for each subsequent write. This function is
-		accessible only from the API code entity (i.e. not from the
-		APIMI code entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN f_pSmearParams		Pointer to structure containing the Params to the
-				write function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverWriteSmearApi(
-			IN	tPOCT6100_WRITE_SMEAR_PARAMS	f_pSmearParams )
-{
-
-	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
-	unsigned int				err;
-
-	/*  The pProcessContext is there in case the user needs context information
-	in order to perform the access. Note that if it is used, the memory pointed 
-	by this pointer	must be allocated by the user beforehand. */
-	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pSmearParams->pProcessContext;
-
-	/* Check if driver context exists. In this implementation, the context */
-	/* contains driver and semaphore information to perform I/O. */
-	if ( pContext == NULL )
-		return cOCT6100_DRIVER_WSMEAR_FAILED_0;
-
-	err = wanec_req_write_smear(
-				pContext->ec_dev,
-				f_pSmearParams->ulWriteAddress,
-				f_pSmearParams->usWriteData,
-				f_pSmearParams->ulWriteLength);
-	if (err){
-		return cOCT6100_DRIVER_WSMEAR_FAILED_1;
-	}
-
-	return cOCT6100_ERR_OK;
-}
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverWriteSmearOs
-
-Description:    Performs a series of write accesses to the chip. The same data
-		word is written to a series of addresses. The writes begin at
-		the start address, and the address is incremented by the
-		indicated amount for each subsequent write. This function is
-		accessible only from the APIMI code entity (i.e. not from the
-		API code entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN f_pSmearParams		Pointer to structure containing the Params to the
-				write function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverWriteSmearOs(
-
-			IN	tPOCT6100_WRITE_SMEAR_PARAMS			f_pSmearParams )
-{
-	/* We assume that the interrupts are blocked during the 
-	Oct6100UserDriverWriteApi calls and that the Oct6100UserDriverWriteSmearApi 
-	function is accessible in an interrupt context */
-
-	return Oct6100UserDriverWriteSmearApi( f_pSmearParams );
-}
-
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverWriteBurstApi
-
-Description:    Performs a series of write accesses to the chip. An array of
-		data words is written to a series of consecutive addresses.
-		The writes begin at the start address with element 0 of the
-		provided array as the data word. The address is incremented by
-		two for each subsequent write. This function is accessible only
-		from the API code entity (i.e. not from the APIMI code entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN f_pSmearParams		Pointer to structure containing the Params to the
-				write function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverWriteBurstApi(
-			IN	tPOCT6100_WRITE_BURST_PARAMS	f_pBurstParams )
-{
-
-	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
-	unsigned int	i, err;
-	unsigned short	*data;
-
-	/*  The pProcessContext is there in case the user needs context information
-	in order to perform the access. Note that if it is used, the memory pointed 
-	by this pointer	must be allocated by the user beforehand. */
-	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pBurstParams->pProcessContext;
-
-	/* Check if driver context exists. In this implementation, the context */
-	/* contains driver and semaphore information to perform I/O. */
-	if ( pContext == NULL )
-		return cOCT6100_DRIVER_WBURST_FAILED_0;
-
-	/* In this case, the message is allocated dynamically since we do not know */
-	/* in advance the size of the array to be passed down to the driver. */
-#if defined(WAN_KERNEL)
-	data = wan_malloc(f_pBurstParams->ulWriteLength * sizeof(unsigned short));
-#else
-	data = malloc(f_pBurstParams->ulWriteLength * sizeof(unsigned short));
-#endif
-	if (data == NULL){
-		return cOCT6100_DRIVER_WBURST_FAILED_1;
-	}
-
-	/* Copy payload to be transported to driver. */
-	for(i = 0; i < f_pBurstParams->ulWriteLength; i++ )
-		data[i] = f_pBurstParams->pusWriteData[i];
-
-	err = wanec_req_write_burst(
-				pContext->ec_dev,
-				f_pBurstParams->ulWriteAddress,
-				data,
-				f_pBurstParams->ulWriteLength);
-	/* Cleanup allocated memory. */
-#if defined(WAN_KERNEL)
-	wan_free( data );
-#else
-	free( data );
-#endif
-
-	if (err){
-		return cOCT6100_DRIVER_WBURST_FAILED_2;
-	}
-
-	return cOCT6100_ERR_OK;
-}
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverWriteBurstOs
-
-Description:    Performs a series of write accesses to the chip. An array of
-		data words is written to a series of consecutive addresses.
-		The writes begin at the start address with element 0 of the
-		provided array as the data word. The address is incremented by
-		two for each subsequent write. This function is accessible only
-		from the API code entity (i.e. not from the APIMI code entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN f_pBurstParams		Pointer to structure containing the Params to the
-				write function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverWriteBurstOs(
-			IN	tPOCT6100_WRITE_BURST_PARAMS	f_pBurstParams )
-{
-
-	/* We assume that the interrupts are blocked during the 
-	Oct6100UserDriverWriteApi calls and that the Oct6100UserDriverWriteBurstApi 
-	function is accessible in an interrupt context */
-	
-	return Oct6100UserDriverWriteBurstApi( f_pBurstParams );
-}
-
-
-
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverReadApi
-
-Description:    Performs a read access to the chip. This function is accessible
-		only from the API code entity (i.e. not from the APIMI code
-		entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN OUT f_pReadParams		Pointer to structure containing the Params to the
-				read function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverReadApi(
-			IN OUT	tPOCT6100_READ_PARAMS	f_pReadParams )
-{
-	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
-	unsigned int				err;
-
-	/*  The pProcessContext is there in case the user needs context information
-	in order to perform the access. Note that if it is used, the memory pointed 
-	by this pointer	must be allocated by the user beforehand. */
-	
-	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pReadParams->pProcessContext;
-
-	/* Check if driver context exists. In this implementation, the context */
-	/* contains driver and semaphore information to perform I/O. */
-	if ( pContext == NULL )
-		return cOCT6100_DRIVER_READ_FAILED_0;
-
-	err = wanec_req_read(
-				pContext->ec_dev,
-				f_pReadParams->ulReadAddress,
-				f_pReadParams->pusReadData);
-	if (err){
-		return cOCT6100_DRIVER_READ_FAILED_1;
-	}
-
-	return cOCT6100_ERR_OK;
-}
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverReadOs
-
-Description:    Performs a read access to the chip. This function is accessible
-		only from the APIMI code entity (i.e. not from the API code
-		entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN OUT f_pReadParams		Pointer to structure containing the Params to the
-				read function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverReadOs(
-			IN OUT	tPOCT6100_READ_PARAMS	f_pReadParams )
-{
-
-	/* We assume that the interrupts are blocked during the 
-	Oct6100UserDriverReadApi calls and that the Oct6100UserDriverReadApi 
-	function is accessible in an interrupt context */
-	return Oct6100UserDriverReadApi( f_pReadParams );
-}
-
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverReadBurstApi
-
-Description:    Performs a burst of read accesses to the chip. The first read
-		is performed at the start address, and the address is
-		incremented by two for each subsequent read. The data is
-		retunred in an array provided by the user. This function is
-		accessible only from the API code entity (i.e. not from the
-		APIMI code entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN OUT f_pBurstParams		Pointer to structure containing the Params to the
-				read function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverReadBurstApi(
-			IN OUT	tPOCT6100_READ_BURST_PARAMS	f_pBurstParams )
-{
-	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
-	unsigned int	i, err;
-	unsigned short	*data;
-
-	/*  The pProcessContext is there in case the user needs context information
-	in order to perform the access. Note that if it is used, the memory pointed 
-	by this pointer	must be allocated by the user beforehand. */
-	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pBurstParams->pProcessContext;
-
-	/* Check if driver context exists. In this implementation, the context */
-	/* contains driver and semaphore information to perform I/O. */
-	if ( pContext == NULL )
-		return cOCT6100_DRIVER_RBURST_FAILED_0;
-
-	/* In this case, the message is allocated dynamically since we do not know */
-	/* in advance the size of the array to be passed down to the driver. */
-#if defined(WAN_KERNEL)
-	data = (unsigned short*)wan_malloc(f_pBurstParams->ulReadLength * sizeof(unsigned short));
-#else
-	data = (unsigned short*)malloc(f_pBurstParams->ulReadLength * sizeof(unsigned short));
-#endif
-	if (data == NULL){
-		return cOCT6100_DRIVER_RBURST_FAILED_1;
-	}
-	err = wanec_req_read_burst(
-				pContext->ec_dev,
-				f_pBurstParams->ulReadAddress,
-				data,
-				f_pBurstParams->ulReadLength);	
-
-	/* Copy result to the user. */
-	if (!err){
-		for(i = 0; i < f_pBurstParams->ulReadLength; i++){
-			f_pBurstParams->pusReadData[i] = data[i];
-		}
-	}
-	
-	/* Cleanup allocated memory. */
-#if defined(WAN_KERNEL)
-	wan_free(data);
-#else
-	free(data);
-#endif
-
-	if (err){
-		return cOCT6100_DRIVER_RBURST_FAILED_2;
-	}
-
-	return cOCT6100_ERR_OK;
-}
-
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
-
-Function:		Oct6100UserDriverReadBurstOs
-
-Description:    Performs a burst of read accesses to the chip. The first read
-		is performed at the start address, and the address is
-		incremented by two for each subsequent read. The data is
-		retunred in an array provided by the user. This function is
-		accessible only from the APIMI code entity (i.e. not from the
-		API code entity).
-
--------------------------------------------------------------------------------
-|	Argument		|	Description
--------------------------------------------------------------------------------
-IN OUT f_pBurstParams		Pointer to structure containing the Params to the
-				read function.
- 
-\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-UINT32 Oct6100UserDriverReadBurstOs(
-			IN OUT	tPOCT6100_READ_BURST_PARAMS	f_pBurstParams )
-{
-	/* We assume that the interrupts are blocked during the 
-	Oct6100UserDriverReadApi calls and that the  
-	Oct6100UserDriverReadBurstApi function is accessible 
-	in an interrupt context */
-	return Oct6100UserDriverReadBurstApi(f_pBurstParams);
-}
-
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+File: oct6100_user.c
+
+	Copyright (c) 2001 Octasic Inc. All rights reserved.
+    
+Description: 
+
+	This file contains the functions provided by the user.
+
+This source code is Octasic Confidential. Use of and access to this code
+is covered by the Octasic Device Enabling Software License Agreement. 
+Acknowledgement of the Octasic Device Enabling Software License was 
+required for access to this code. A copy was also provided with the release.
+
+
+$Octasic_Release: OCT612xAPI-01.00-PR37 $
+
+$Octasic_Revision: 25 $
+
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+
+
+/*****************************  INCLUDE FILES  *******************************/
+
+
+/* System specific includes */
+#if defined(WAN_EC_USER)
+# include <unistd.h>
+# include <stdio.h>
+# include <stdlib.h>
+# include <time.h>
+# include <sys/fcntl.h>
+# include <sys/time.h>
+# include <sys/stat.h>
+# include <sys/types.h>
+# include <sys/ipc.h>
+# include <sys/sem.h>
+# include <sys/queue.h>
+# include <getopt.h>
+# include <limits.h>
+# include <errno.h>
+# include <memory.h>
+# include <signal.h>
+# include <semaphore.h>
+# include <sys/ioctl.h>
+# if defined(__LINUX__)
+#  include <linux/wanpipe_defines.h>
+#  include <linux/wanpipe_cfg.h>
+# elif defined(__FreeBSD__) || defined(__OpenBSD__)
+#  include <wanpipe_defines.h>
+#  include <wanpipe_cfg.h>
+# endif
+# include "oct6100api/oct6100_apiud.h"
+# include "oct6100api/oct6100_errors.h"
+# include "oct6100api/oct6100_api.h"
+# include "oct6100_version.h"
+# include "wanec_iface.h"
+#else
+# if defined(__LINUX__)
+#  include <linux/wanpipe_includes.h>
+#  include <linux/wanpipe_defines.h>
+#  include <linux/wanpipe_debug.h>
+#  include <linux/wanpipe_common.h>
+#  include <linux/wanpipe_cfg.h>
+#  include <linux/if_wanpipe.h>
+#  include <linux/wanpipe.h>
+# else
+#  include <wanpipe_includes.h>
+#  include <wanpipe_defines.h>
+#  include <wanpipe_debug.h>
+#  include <wanpipe_common.h>
+#  include <wanpipe.h>
+#  include <wanpipe_cfg.h>
+# endif
+
+#include "oct6100api/oct6100_apiud.h"
+#include "oct6100api/oct6100_errors.h"
+
+#include "oct6100api/oct6100_api.h"
+#include "oct6100_version.h"
+
+# include "wanec_iface.h"
+#endif
+
+extern u_int32_t wanec_req_write(void*, u_int32_t write_addr, u_int16_t write_data);
+extern u_int32_t wanec_req_write_smear(void*, u_int32_t addr, u_int16_t data, u_int32_t len);
+extern u_int32_t wanec_req_write_burst(void*, u_int32_t addr, u_int16_t *data, u_int32_t len);
+extern u_int32_t wanec_req_read(void*, u_int32_t addr, u_int16_t *data);
+extern u_int32_t wanec_req_read_burst(void*, u_int32_t addr, u_int16_t *data, u_int32_t len);
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserGetTime
+
+Description:	Returns the system time in us.
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN OUT f_pTime		Pointer to structure in which the time is returned.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+
+UINT32 Oct6100UserGetTime(
+
+			IN OUT tPOCT6100_GET_TIME	f_pTime )
+{
+	clock_t		ulClockTicks;
+	struct timeval	TimeVal;
+	static UINT32	ulWallTimeUsHigh = 0;
+	static UINT32	ulWallTimeUsLow = 0;
+
+	if( !f_pTime )
+		return cOCT6100_GET_TIME_FAILED_0;
+
+#if !defined(__WINDOWS__)
+	/* Retrieve clock tick */
+#if defined(WAN_KERNEL)
+	wan_getcurrenttime( &TimeVal.tv_sec, &TimeVal.tv_usec );
+#else
+	gettimeofday( &TimeVal, NULL );
+#endif
+	/* ulClockTicks = ( TimeVal.tv_sec * 1000000 ) + ( TimeVal.tv_usec ); */
+	/* Create a value im ms (as clock does) */
+	ulClockTicks = ( TimeVal.tv_sec * 1000 ) + ( TimeVal.tv_usec /1000 );
+#else
+	ulClockTicks = wpabs_get_systemticks();
+#endif
+
+	/* move to micro sec */
+	ulClockTicks *= 1000;
+
+	/* Did it wrap ? */
+	if ( (UINT32)ulClockTicks < ulWallTimeUsLow )
+	{
+		/* Yes, so increment MSB */
+		ulWallTimeUsHigh++;
+	}
+
+	f_pTime->aulWallTimeUs[ 0 ] = ulClockTicks;
+	f_pTime->aulWallTimeUs[ 1 ] = ulWallTimeUsHigh;
+	ulWallTimeUsLow = f_pTime->aulWallTimeUs[ 0 ];
+
+	return cOCT6100_ERR_OK;
+}
+
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserMemSet
+
+Description:	Sets f_ulLength bytes pointed to by f_pAddress to f_ulPattern.
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserMemSet(
+			IN	PVOID	f_pAddress,
+			IN	UINT32	f_ulPattern,
+			IN	UINT32	f_ulLength )
+{
+
+	memset( f_pAddress, f_ulPattern, f_ulLength );
+
+	return cOCT6100_ERR_OK;
+}
+
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserMemCopy
+
+Description:	Copy f_ulLength bytes from f_pSource to f_pDestination.
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserMemCopy(
+			IN	PVOID	f_pDestination,
+			IN	PVOID	f_pSource,
+			IN	UINT32	f_ulLength )
+{
+
+	memcpy( f_pDestination, f_pSource, f_ulLength );
+
+	return cOCT6100_ERR_OK;
+}
+
+
+#if !defined(WAN_KERNEL)
+static void SigArlmHandler()
+{
+}
+#endif
+
+#if defined(__GNU_LIBRARY__) && !defined(_SEM_SEMUN_UNDEFINED) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(WAN_KERNEL)
+/* union semun is defined by including <sys/sem.h> */
+#else
+/* according to X/OPEN we have to define it ourselves */
+union semun {
+	int val;                  /* value for SETVAL */
+	struct semid_ds *buf;     /* buffer for IPC_STAT, IPC_SET */
+	unsigned short *array;    /* array for GETALL, SETALL */
+                              /* Linux specific part: */
+	struct seminfo *__buf;    /* buffer for IPC_INFO */
+};
+#endif
+
+typedef struct _SEM_FILE_INF_
+{
+	UINT32		ulMainProcessId;
+	UINT32		ulUsageCount;
+
+} tSEM_FILE_INF, *tPSEM_FILE_INF;
+
+typedef struct _SEM_INF_
+{
+	INT			SemId;
+	CHAR		szFileName[PATH_MAX];
+
+} tSEM_INF, *tPSEM_INF;
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserCreateSerializeObject
+
+Description:	Creates a serialization object. The serialization object is
+				seized via the Oct6100UserSeizeSerializeObject function.
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN OUT f_pCreate		Pointer to structure in which the serialization object's
+				handle is returned.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserCreateSerializeObject(
+
+		IN OUT tPOCT6100_CREATE_SERIALIZE_OBJECT	f_pCreate )
+{
+
+#if !defined(WAN_KERNEL)
+
+	UINT32					ulRc = cOCT6100_ERR_OK;
+	INT					SemId;
+	FILE *					hSemFile = NULL;
+	BOOL					fFileCreated = FALSE;
+	key_t					Key;
+	int					iSemCnt = 1;
+	tPSEM_INF				pSemInf = NULL;
+	union semun 				SemArg;
+	tSEM_FILE_INF				SemFileInf;
+	struct stat				FileStat;
+	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
+
+	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pCreate->pProcessContext;
+
+	if ( ( f_pCreate == NULL ) || ( f_pCreate->pszSerialObjName == NULL )  )
+		return cOCT6100_CREATE_SERIAL_FAILED_0;
+
+	/* Alloc a sem inf structure */
+	pSemInf = (tPSEM_INF)malloc( sizeof(tSEM_INF) );
+
+	/* Check if malloc failed!!! */
+	if ( pSemInf == NULL )
+		return cOCT6100_CREATE_SERIAL_FAILED_0; /* No memory. */
+
+	snprintf( pSemInf->szFileName, PATH_MAX, "/tmp/%s", f_pCreate->pszSerialObjName );
+
+	/* File exist? */
+	if( stat( pSemInf->szFileName, &FileStat ) )
+	{
+		/* Not main process, this file must exist */
+		if ( pContext->fMainProcess == FALSE )
+		{
+			/* The file does not exist, and we are not the main process. */
+			ulRc = cOCT6100_CREATE_SERIAL_FAILED_1;
+		}
+		else
+		{
+			/* create the file */
+			hSemFile = fopen( pSemInf->szFileName, "w+b" );
+			if( !hSemFile )
+			{
+				ulRc = cOCT6100_CREATE_SERIAL_FAILED_2;
+			}
+			else
+			{
+				fFileCreated = TRUE;
+				memset( &SemFileInf, 0x0, sizeof(SemFileInf) );
+			}
+		}
+		SemFileInf.ulMainProcessId = getpid();
+	}
+	else
+	{
+		/* The semaphore exists.  Open it. */
+		hSemFile = fopen( pSemInf->szFileName, "r+b" );
+		/* Retrieve info from file */
+		if ( sizeof(SemFileInf) != fread( &SemFileInf, 1, sizeof(SemFileInf), hSemFile ) )
+		{
+			ulRc = cOCT6100_CREATE_SERIAL_FAILED_2;
+		}
+		/* rewind file */
+		rewind( hSemFile );
+	}
+
+	if ( cOCT6100_ERR_OK == ulRc )
+	{
+		/* This will create a key with upper bits set to 'K' ( 0x4b ) */
+		Key = ftok( pSemInf->szFileName, 'K' );
+
+		if ( -1 == Key )
+		{
+			ulRc = cOCT6100_CREATE_SERIAL_FAILED_2;
+		}
+	}
+
+	if ( cOCT6100_ERR_OK == ulRc )
+	{
+		/* Get the semaphore or create it */
+		SemId = semget( Key, iSemCnt, IPC_CREAT | 0666 /* | IPC_EXCL */ );
+
+		if ( -1 == SemId )
+		{
+			ulRc = cOCT6100_CREATE_SERIAL_FAILED_3;
+		}
+	}
+
+	if ( cOCT6100_ERR_OK == ulRc )
+	{
+		SemArg.val = 1;
+		iSemCnt = 0;
+		if ( 0 == semctl( SemId, iSemCnt, SETVAL, SemArg ))
+		{
+			/* Store handle and id */
+			pSemInf->SemId = SemId;
+
+			/* increment usage count */
+			SemFileInf.ulUsageCount++;
+			/* write file */
+			if ( sizeof(SemFileInf) != fwrite( &SemFileInf, 1, sizeof(SemFileInf), hSemFile ) )
+			{
+				ulRc = cOCT6100_CREATE_SERIAL_FAILED_4;
+			}
+			else
+			{
+				/* commit write */
+				fflush( hSemFile );
+				fclose( hSemFile );
+				signal( SIGALRM, SigArlmHandler );
+				
+				/* Keep pointer to semaphore information. */
+				f_pCreate->ulSerialObjHndl = (UINT32)pSemInf;	
+			}
+		}
+		else
+		{
+			ulRc = cOCT6100_CREATE_SERIAL_FAILED_4;
+		}
+	}
+	
+	/* Any errors ? */
+	if ( cOCT6100_ERR_OK != ulRc )
+	{
+		if ( -1 != SemId )
+		{
+			/* remove semaphore */
+			semctl( SemId, 0, IPC_RMID, SemArg );    
+		}
+		if ( NULL != hSemFile )
+		{
+			fclose( hSemFile );
+		}
+
+		if ( pSemInf )
+		{
+			if ( fFileCreated )
+			{
+				unlink( pSemInf->szFileName );
+			}
+
+			free( pSemInf );
+		}
+	}
+
+	return ulRc;
+#else
+
+	return cOCT6100_ERR_OK;
+#endif
+}
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDestroySerializeObject
+
+Description:	Destroys the indicated serialization object.
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN f_pDestroy			Pointer to structure containing the handle of the
+				serialization object.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDestroySerializeObject(
+
+			IN tPOCT6100_DESTROY_SERIALIZE_OBJECT		f_pDestroy )
+{	
+
+#if !defined(WAN_KERNEL)
+	UINT32		ulRc = cOCT6100_ERR_OK;
+	tPSEM_INF	pSemInf;
+
+	if ( ( f_pDestroy == NULL ) || ( f_pDestroy->ulSerialObjHndl == 0x0 ) )
+		return cOCT6100_DESTROY_SERIAL_FAILED_0;
+
+	pSemInf = (tPSEM_INF)(f_pDestroy->ulSerialObjHndl);
+
+	/* Check mutex handle */
+	if ( -1 != pSemInf->SemId )
+	{
+		FILE *			hSemFile = NULL;
+		tSEM_FILE_INF	SemFileInf;
+
+		/* Default is failure */
+		ulRc = cOCT6100_DESTROY_SERIAL_FAILED_0;
+
+		hSemFile = fopen( pSemInf->szFileName, "rb" );
+
+		if ( hSemFile )
+		{
+			/* read sem file inf */
+			if ( sizeof(SemFileInf) == fread( &SemFileInf, 1, sizeof(SemFileInf), hSemFile ) )
+			{
+				/* remove a link on that sem */
+				if ( SemFileInf.ulUsageCount > 0 )
+				{
+					SemFileInf.ulUsageCount--;
+				}
+
+				/* Last reference gone ? */
+				if( !SemFileInf.ulUsageCount )
+				{
+					union semun 	SemArg;
+
+					/* Close semaphore, this must be called when no one is waiting on sem */
+					if( semctl( pSemInf->SemId, 0, IPC_RMID, SemArg ) != -1 )
+					{
+						/* Close file */
+						fclose( hSemFile );
+						/* delete file */
+						unlink( pSemInf->szFileName );
+						/* release memory */
+						free( pSemInf );
+
+						/* return done */
+						f_pDestroy->ulSerialObjHndl = 0x0;
+						ulRc = cOCT6100_ERR_OK;
+					}
+				}
+				else
+				{
+					/* commit change */
+					rewind( hSemFile );
+					fwrite( &SemFileInf, 1, sizeof(SemFileInf), hSemFile );
+					/* commit write */
+					fflush( hSemFile );
+					fclose( hSemFile );
+					free( pSemInf );
+					/* If not in the main process, nothing much to do ... */
+					f_pDestroy->ulSerialObjHndl = 0x0;
+					ulRc = cOCT6100_ERR_OK;
+				}
+			}
+		}
+	}
+
+	return ulRc;
+#else
+
+	return cOCT6100_ERR_OK;
+#endif
+}
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserSeizeSerializeObject
+
+Description:	Seizes the indicated serialization object.
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN f_pSeize			Pointer to structure containing the handle of the
+				serialization object.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserSeizeSerializeObject(
+
+			IN tPOCT6100_SEIZE_SERIALIZE_OBJECT			f_pSeize )
+{
+
+#if !defined(WAN_KERNEL)
+	UINT32			ulRc = cOCT6100_ERR_OK;
+	tPSEM_INF		pSemInf;
+
+	if( f_pSeize == NULL )
+		return cOCT6100_SEIZE_SERIAL_FAILED_0;
+
+	if ( f_pSeize->ulSerialObjHndl == 0 )
+		return cOCT6100_SEIZE_SERIAL_FAILED_0;
+
+	pSemInf = (tPSEM_INF)f_pSeize->ulSerialObjHndl;
+
+	/* Check mutex handle */
+	if ( pSemInf )
+	{
+		INT			iRes = 0;
+		struct itimerval	TimerSetting;
+
+		ulRc = cOCT6100_SEIZE_SERIAL_FAILED_1;
+		
+		/* Check if must create a timer. */
+		if( cOCT6100_WAIT_INFINITELY != f_pSeize->ulTryTimeMs )
+		{
+			/* Set the alarm */
+			TimerSetting.it_value.tv_sec = ( f_pSeize->ulTryTimeMs / 1000 );
+			TimerSetting.it_value.tv_usec = ( f_pSeize->ulTryTimeMs % 1000 ) * 1000;
+			/* No repeat please! */
+			TimerSetting.it_interval.tv_sec = 0;
+			TimerSetting.it_interval.tv_usec = 0;
+
+			iRes = setitimer( ITIMER_REAL, &TimerSetting, NULL );
+		}
+		
+		if( iRes != -1 )
+		{
+			/* Timer is armed! */
+			struct sembuf LockSEM[1] = { { 0, -1, SEM_UNDO } };
+
+			iRes = semop( pSemInf->SemId, LockSEM, 1 );
+
+			if( iRes == -1 )
+			{
+				switch( errno )
+				{
+					case EINTR:
+						ulRc = cOCT6100_SEIZE_SERIAL_FAILED_2;
+						break;
+					default:
+						break;
+				}
+			}
+			else
+			{
+				ulRc = cOCT6100_ERR_OK;
+			}
+			
+			if( cOCT6100_WAIT_INFINITELY != f_pSeize->ulTryTimeMs )
+			{
+				/* Disarm timer */
+				TimerSetting.it_value.tv_sec = 0;
+				TimerSetting.it_value.tv_usec = 0;
+
+				setitimer( ITIMER_REAL, &TimerSetting, NULL );
+			}
+		}
+	}
+	return( ulRc );
+#else
+	return cOCT6100_ERR_OK;
+
+#endif
+
+}
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserReleaseSerializeObject
+
+Description:	Releases the indicated serialization object.
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN f_pRelease			Pointer to structure containing the handle of the
+				serialization object.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserReleaseSerializeObject(
+
+			IN tPOCT6100_RELEASE_SERIALIZE_OBJECT		f_pRelease )
+{
+
+#if !defined(WAN_KERNEL)
+	UINT32		ulRc = cOCT6100_ERR_OK;
+	tPSEM_INF	pSemInf;
+
+	if( f_pRelease == NULL )
+		return cOCT6100_RELEASE_SERIAL_FAILED_0;
+
+	if ( f_pRelease->ulSerialObjHndl == 0 )
+		return cOCT6100_RELEASE_SERIAL_FAILED_0;
+
+	pSemInf = (tPSEM_INF)f_pRelease->ulSerialObjHndl;
+
+	/* Check mutex handle */
+	if ( pSemInf )
+	{
+		struct sembuf UnlockSEM[1] = { { 0, 1, SEM_UNDO } };
+		int iRes;
+		
+		ulRc = cOCT6100_ERR_OK;
+
+		iRes = semop( pSemInf->SemId, UnlockSEM, 1 );
+
+		if( iRes == -1 )
+		{
+			ulRc = cOCT6100_RELEASE_SERIAL_FAILED_1;
+		}
+	}
+
+	return( ulRc );
+#else
+
+	return cOCT6100_ERR_OK;
+#endif
+
+}
+
+
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverWriteApi
+
+Description:    Performs a write access to the chip. This function is
+		accessible only from the API code entity (i.e. not from the
+		APIMI code entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN f_pWriteParams		Pointer to structure containing the Params to the
+				write function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverWriteApi(
+			IN	tPOCT6100_WRITE_PARAMS	f_pWriteParams )
+{
+	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
+	unsigned int				err;
+
+	/*  The pProcessContext is there in case the user needs context information
+	in order to perform the access. Note that if it is used, the memory pointed 
+	by this pointer	must be allocated by the user beforehand. */
+	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pWriteParams->pProcessContext;
+
+	/* Check if driver context exists. In this implementation, the context */
+	/* contains driver and semaphore information to perform I/O. */
+	if ( pContext == NULL )
+		return cOCT6100_DRIVER_WRITE_FAILED_0;
+
+	err = wanec_req_write(
+				pContext->ec_dev,
+				f_pWriteParams->ulWriteAddress,
+				f_pWriteParams->usWriteData);
+	if (err){
+		return cOCT6100_DRIVER_WRITE_FAILED_1;
+	}
+	return cOCT6100_ERR_OK;
+}
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverWriteOs
+
+Description:    Performs a write access to the chip. This function is
+		accessible only from the APIMI code entity (i.e. not from the
+		API code entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN f_pWriteParams		Pointer to structure containing the Params to the
+				write function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverWriteOs(
+			IN	tPOCT6100_WRITE_PARAMS	f_pWriteParams )
+{
+
+	/* We assume that the interrupts are blocked during the 
+	Oct6100UserDriverWriteApi calls and that the Oct6100UserDriverWriteApi 
+	function is accessible in an interrupt context */
+
+	return Oct6100UserDriverWriteApi( f_pWriteParams );
+}
+
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverWriteSmearApi
+
+Description:    Performs a series of write accesses to the chip. The same data
+		word is written to a series of addresses. The writes begin at
+		the start address, and the address is incremented by the
+		indicated amount for each subsequent write. This function is
+		accessible only from the API code entity (i.e. not from the
+		APIMI code entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN f_pSmearParams		Pointer to structure containing the Params to the
+				write function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverWriteSmearApi(
+			IN	tPOCT6100_WRITE_SMEAR_PARAMS	f_pSmearParams )
+{
+
+	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
+	unsigned int				err;
+
+	/*  The pProcessContext is there in case the user needs context information
+	in order to perform the access. Note that if it is used, the memory pointed 
+	by this pointer	must be allocated by the user beforehand. */
+	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pSmearParams->pProcessContext;
+
+	/* Check if driver context exists. In this implementation, the context */
+	/* contains driver and semaphore information to perform I/O. */
+	if ( pContext == NULL )
+		return cOCT6100_DRIVER_WSMEAR_FAILED_0;
+
+	err = wanec_req_write_smear(
+				pContext->ec_dev,
+				f_pSmearParams->ulWriteAddress,
+				f_pSmearParams->usWriteData,
+				f_pSmearParams->ulWriteLength);
+	if (err){
+		return cOCT6100_DRIVER_WSMEAR_FAILED_1;
+	}
+
+	return cOCT6100_ERR_OK;
+}
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverWriteSmearOs
+
+Description:    Performs a series of write accesses to the chip. The same data
+		word is written to a series of addresses. The writes begin at
+		the start address, and the address is incremented by the
+		indicated amount for each subsequent write. This function is
+		accessible only from the APIMI code entity (i.e. not from the
+		API code entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN f_pSmearParams		Pointer to structure containing the Params to the
+				write function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverWriteSmearOs(
+
+			IN	tPOCT6100_WRITE_SMEAR_PARAMS			f_pSmearParams )
+{
+	/* We assume that the interrupts are blocked during the 
+	Oct6100UserDriverWriteApi calls and that the Oct6100UserDriverWriteSmearApi 
+	function is accessible in an interrupt context */
+
+	return Oct6100UserDriverWriteSmearApi( f_pSmearParams );
+}
+
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverWriteBurstApi
+
+Description:    Performs a series of write accesses to the chip. An array of
+		data words is written to a series of consecutive addresses.
+		The writes begin at the start address with element 0 of the
+		provided array as the data word. The address is incremented by
+		two for each subsequent write. This function is accessible only
+		from the API code entity (i.e. not from the APIMI code entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN f_pSmearParams		Pointer to structure containing the Params to the
+				write function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverWriteBurstApi(
+			IN	tPOCT6100_WRITE_BURST_PARAMS	f_pBurstParams )
+{
+
+	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
+	unsigned int	i, err;
+	unsigned short	*data;
+#if defined(__WINDOWS__)
+	unsigned char tmp_buf[OCT_TMP_MEMORY_SIZE];
+	int rc = SILENT;
+#endif
+
+	/*  The pProcessContext is there in case the user needs context information
+	in order to perform the access. Note that if it is used, the memory pointed 
+	by this pointer	must be allocated by the user beforehand. */
+	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pBurstParams->pProcessContext;
+
+	/* Check if driver context exists. In this implementation, the context */
+	/* contains driver and semaphore information to perform I/O. */
+	if ( pContext == NULL )
+		return cOCT6100_DRIVER_WBURST_FAILED_0;
+
+	/* In this case, the message is allocated dynamically since we do not know */
+	/* in advance the size of the array to be passed down to the driver. */
+#if defined(WAN_KERNEL)
+# if !defined(__WINDOWS__)
+	data = wan_malloc(f_pBurstParams->ulWriteLength * sizeof(unsigned short));
+# else
+	VERIFY_DISPATCH_IRQL(rc);
+	if(rc){
+		//Memory allocation is invalid inside ISR, use a temp buffer.
+		if(f_pBurstParams->ulWriteLength * sizeof(unsigned short) > OCT_TMP_MEMORY_SIZE){
+			DEBUG_EVENT("%s(): Memory requested (%d) bigger than 'temp' (%d) buffer!!\n",
+				__FUNCTION__, f_pBurstParams->ulWriteLength * sizeof(unsigned short), OCT_TMP_MEMORY_SIZE);
+			return cOCT6100_DRIVER_WBURST_FAILED_1;
+		}
+		data = (unsigned short*)tmp_buf;
+	}else{
+		data = wan_malloc(f_pBurstParams->ulWriteLength * sizeof(unsigned short));
+	}
+# endif
+#else
+	data = malloc(f_pBurstParams->ulWriteLength * sizeof(unsigned short));
+#endif
+	if (data == NULL){
+		return cOCT6100_DRIVER_WBURST_FAILED_1;
+	}
+
+	/* Copy payload to be transported to driver. */
+	for(i = 0; i < f_pBurstParams->ulWriteLength; i++ )
+		data[i] = f_pBurstParams->pusWriteData[i];
+
+	err = wanec_req_write_burst(
+				pContext->ec_dev,
+				f_pBurstParams->ulWriteAddress,
+				data,
+				f_pBurstParams->ulWriteLength);
+	/* Cleanup allocated memory. */
+#if defined(WAN_KERNEL)
+# if !defined(__WINDOWS__)
+	wan_free( data );
+# else
+	rc = SILENT;
+	VERIFY_DISPATCH_IRQL(rc);
+	if(rc == 0){
+		wan_free(data);
+	}
+# endif
+#else
+	free( data );
+#endif
+
+	if (err){
+		return cOCT6100_DRIVER_WBURST_FAILED_2;
+	}
+
+	return cOCT6100_ERR_OK;
+}
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverWriteBurstOs
+
+Description:    Performs a series of write accesses to the chip. An array of
+		data words is written to a series of consecutive addresses.
+		The writes begin at the start address with element 0 of the
+		provided array as the data word. The address is incremented by
+		two for each subsequent write. This function is accessible only
+		from the API code entity (i.e. not from the APIMI code entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN f_pBurstParams		Pointer to structure containing the Params to the
+				write function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverWriteBurstOs(
+			IN	tPOCT6100_WRITE_BURST_PARAMS	f_pBurstParams )
+{
+
+	/* We assume that the interrupts are blocked during the 
+	Oct6100UserDriverWriteApi calls and that the Oct6100UserDriverWriteBurstApi 
+	function is accessible in an interrupt context */
+	
+	return Oct6100UserDriverWriteBurstApi( f_pBurstParams );
+}
+
+
+
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverReadApi
+
+Description:    Performs a read access to the chip. This function is accessible
+		only from the API code entity (i.e. not from the APIMI code
+		entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN OUT f_pReadParams		Pointer to structure containing the Params to the
+				read function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverReadApi(
+			IN OUT	tPOCT6100_READ_PARAMS	f_pReadParams )
+{
+	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
+	unsigned int				err;
+
+	/*  The pProcessContext is there in case the user needs context information
+	in order to perform the access. Note that if it is used, the memory pointed 
+	by this pointer	must be allocated by the user beforehand. */
+	
+	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pReadParams->pProcessContext;
+
+	/* Check if driver context exists. In this implementation, the context */
+	/* contains driver and semaphore information to perform I/O. */
+	if ( pContext == NULL )
+		return cOCT6100_DRIVER_READ_FAILED_0;
+
+	err = wanec_req_read(
+				pContext->ec_dev,
+				f_pReadParams->ulReadAddress,
+				f_pReadParams->pusReadData);
+	if (err){
+		return cOCT6100_DRIVER_READ_FAILED_1;
+	}
+
+	return cOCT6100_ERR_OK;
+}
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverReadOs
+
+Description:    Performs a read access to the chip. This function is accessible
+		only from the APIMI code entity (i.e. not from the API code
+		entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN OUT f_pReadParams		Pointer to structure containing the Params to the
+				read function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverReadOs(
+			IN OUT	tPOCT6100_READ_PARAMS	f_pReadParams )
+{
+
+	/* We assume that the interrupts are blocked during the 
+	Oct6100UserDriverReadApi calls and that the Oct6100UserDriverReadApi 
+	function is accessible in an interrupt context */
+	return Oct6100UserDriverReadApi( f_pReadParams );
+}
+
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverReadBurstApi
+
+Description:    Performs a burst of read accesses to the chip. The first read
+		is performed at the start address, and the address is
+		incremented by two for each subsequent read. The data is
+		retunred in an array provided by the user. This function is
+		accessible only from the API code entity (i.e. not from the
+		APIMI code entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN OUT f_pBurstParams		Pointer to structure containing the Params to the
+				read function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverReadBurstApi(
+			IN OUT	tPOCT6100_READ_BURST_PARAMS	f_pBurstParams )
+{
+	tPOCTPCIDRV_USER_PROCESS_CONTEXT	pContext;
+	unsigned int	i, err;
+	unsigned short	*data;
+#if defined(__WINDOWS__)
+	unsigned char tmp_buf[OCT_TMP_MEMORY_SIZE];
+	int rc = SILENT;
+#endif
+
+	/*  The pProcessContext is there in case the user needs context information
+	in order to perform the access. Note that if it is used, the memory pointed 
+	by this pointer	must be allocated by the user beforehand. */
+	pContext = (tPOCTPCIDRV_USER_PROCESS_CONTEXT)f_pBurstParams->pProcessContext;
+
+	/* Check if driver context exists. In this implementation, the context */
+	/* contains driver and semaphore information to perform I/O. */
+	if ( pContext == NULL )
+		return cOCT6100_DRIVER_RBURST_FAILED_0;
+
+	/* In this case, the message is allocated dynamically since we do not know */
+	/* in advance the size of the array to be passed down to the driver. */
+#if defined(WAN_KERNEL)
+# if !defined(__WINDOWS__)
+	data = (unsigned short*)wan_malloc(f_pBurstParams->ulReadLength * sizeof(unsigned short));
+# else
+	VERIFY_DISPATCH_IRQL(rc);
+	if(rc){
+		//Memory allocation is invalid inside ISR, use a temp buffer.
+		if(f_pBurstParams->ulReadLength * sizeof(unsigned short) > OCT_TMP_MEMORY_SIZE){
+			DEBUG_EVENT("%s(): Memory requested (%d) bigger than 'temp' (%d) buffer!!\n",
+				__FUNCTION__, f_pBurstParams->ulReadLength * sizeof(unsigned short), OCT_TMP_MEMORY_SIZE);
+			return cOCT6100_DRIVER_WBURST_FAILED_1;
+		}
+		data = (unsigned short*)tmp_buf;
+	}else{
+		data = (unsigned short*)wan_malloc(f_pBurstParams->ulReadLength * sizeof(unsigned short));
+	}
+# endif
+#else
+	data = (unsigned short*)malloc(f_pBurstParams->ulReadLength * sizeof(unsigned short));
+#endif
+	if (data == NULL){
+		return cOCT6100_DRIVER_RBURST_FAILED_1;
+	}
+	err = wanec_req_read_burst(
+				pContext->ec_dev,
+				f_pBurstParams->ulReadAddress,
+				data,
+				f_pBurstParams->ulReadLength);	
+
+	/* Copy result to the user. */
+	if (!err){
+		for(i = 0; i < f_pBurstParams->ulReadLength; i++){
+			f_pBurstParams->pusReadData[i] = data[i];
+		}
+	}
+	
+	/* Cleanup allocated memory. */
+#if defined(WAN_KERNEL)
+# if !defined(__WINDOWS__)
+	wan_free(data);
+# else
+	rc = SILENT;
+	VERIFY_DISPATCH_IRQL(rc);
+	if(rc == 0){
+		wan_free(data);
+	}
+# endif
+#else
+	free(data);
+#endif
+
+	if (err){
+		return cOCT6100_DRIVER_RBURST_FAILED_2;
+	}
+
+	return cOCT6100_ERR_OK;
+}
+
+/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*\
+
+Function:		Oct6100UserDriverReadBurstOs
+
+Description:    Performs a burst of read accesses to the chip. The first read
+		is performed at the start address, and the address is
+		incremented by two for each subsequent read. The data is
+		retunred in an array provided by the user. This function is
+		accessible only from the APIMI code entity (i.e. not from the
+		API code entity).
+
+-------------------------------------------------------------------------------
+|	Argument		|	Description
+-------------------------------------------------------------------------------
+IN OUT f_pBurstParams		Pointer to structure containing the Params to the
+				read function.
+ 
+\*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
+UINT32 Oct6100UserDriverReadBurstOs(
+			IN OUT	tPOCT6100_READ_BURST_PARAMS	f_pBurstParams )
+{
+	/* We assume that the interrupts are blocked during the 
+	Oct6100UserDriverReadApi calls and that the  
+	Oct6100UserDriverReadBurstApi function is accessible 
+	in an interrupt context */
+	return Oct6100UserDriverReadBurstApi(f_pBurstParams);
+}
+
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: .oct6100_user.o.cmd
Only in wanec/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_api: sources
Only in wanec/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_apimi: CVS
Only in wanec.old/oct6100_api.PR43/octdeviceapi/oct6100api/oct6100_apimi: .oct6100_mask_interrupts.o.cmd
Only in wanec/oct6100_api.PR43/octdeviceapiw: CVS
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_freebsd: CVS
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: CVS
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_adpcm_chan.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_adpcm_chan.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_channel.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_channel.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_chip_open.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_chip_open.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_chip_stats.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_chip_stats.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_conf_bridge.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_conf_bridge.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_debug.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_debug.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_events.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_events.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_interrupts.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_interrupts.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_mask_interrupts.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_mask_interrupts.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_memory.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_memory.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_miscellaneous.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_miscellaneous.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_mixer.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_mixer.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_phasing_tsst.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_phasing_tsst.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_playout_buf.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_playout_buf.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_remote_debug.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_remote_debug.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_tlv.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_tlv.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_tone_detection.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_tone_detection.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_tsi_cnct.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_tsi_cnct.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_tsst.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_tsst.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_user.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: oct6100_user.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: octapi_bt0.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: octapi_bt0.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: octapi_largmath.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: octapi_largmath.o
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: octapi_llman.d
Only in wanec/oct6100_api.PR43/octdeviceapiw/oct6100_apiw_linux: octapi_llman.o
Only in wanec/tmp: CVS
Only in wanec/tmp: oct6100_adpcm_chan.o
Only in wanec/tmp: oct6100_channel.o
Only in wanec/tmp: oct6100_chip_open.o
Only in wanec/tmp: oct6100_chip_stats.o
Only in wanec/tmp: oct6100_conf_bridge.o
Only in wanec/tmp: oct6100_debug.o
Only in wanec/tmp: oct6100_events.o
Only in wanec/tmp: oct6100_interrupts.o
Only in wanec/tmp: oct6100_mask_interrupts.o
Only in wanec/tmp: oct6100_memory.o
Only in wanec/tmp: oct6100_miscellaneous.o
Only in wanec/tmp: oct6100_mixer.o
Only in wanec/tmp: oct6100_phasing_tsst.o
Only in wanec/tmp: oct6100_playout_buf.o
Only in wanec/tmp: oct6100_remote_debug.o
Only in wanec/tmp: oct6100_tlv.o
Only in wanec/tmp: oct6100_tone_detection.o
Only in wanec/tmp: oct6100_tsi_cnct.o
Only in wanec/tmp: oct6100_tsst.o
Only in wanec/tmp: oct6100_user.o
Only in wanec/tmp: octapi_bt0.o
Only in wanec/tmp: octapi_largmath.o
Only in wanec/tmp: octapi_llman.o
Only in wanec/tmp: wanec_cmd.o
Only in wanec/tmp: wanec_dev.o
Only in wanec/tmp: wanec_iface.o
Only in wanec/tmp: wanec_utils.o
Only in wanec.old/: .tmp_versions
Only in wanec.old/: wanec_build.sh
Only in wanec.old/: .wanec_cmd.o.cmd
Only in wanec.old/: .wanec_dev.o.cmd
Only in wanec.old/: .wanec_iface.o.cmd
Only in wanec.old/: .wanec.ko.cmd
Only in wanec.old/: wanec.mod.c
Only in wanec.old/: .wanec.mod.o.cmd
Only in wanec.old/: .wanec.o.cmd
Only in wanec.old/: .wanec_utils.o.cmd
